(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../core/vdom", "../shim/array", "../core/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var vdom_1 = require("../core/vdom");
    var array_1 = require("../shim/array");
    var util_1 = require("../core/util");
    function isNode(node) {
        return vdom_1.isVNode(node) || vdom_1.isWNode(node);
    }
    function isWrappedNode(node) {
        return Boolean(isNode(node) && node.id);
    }
    function isIgnoredNode(node) {
        return Boolean(node && node.isIgnore && isNode(node));
    }
    function isSameType(expected, actual) {
        if (isNode(expected) && isNode(actual)) {
            if (vdom_1.isVNode(expected) && vdom_1.isVNode(actual) && expected.tag === actual.tag) {
                return true;
            }
            return vdom_1.isWNode(expected) && vdom_1.isWNode(actual) && expected.widgetConstructor === actual.widgetConstructor;
        }
        return false;
    }
    function decorateNodes(dNode) {
        var hasDeferredProperties = false;
        function addParent(parent) {
            (parent.children || []).forEach(function (child) {
                if (vdom_1.isVNode(child) || vdom_1.isWNode(child)) {
                    child.parent = parent;
                }
            });
            if (vdom_1.isVNode(parent) && typeof parent.deferredPropertiesCallback === 'function') {
                hasDeferredProperties = true;
                parent.properties = tslib_1.__assign({}, parent.properties, parent.deferredPropertiesCallback(false));
            }
        }
        var nodes = util_1.decorate(dNode, addParent, function (node) { return vdom_1.isWNode(node) || vdom_1.isVNode(node); });
        return { hasDeferredProperties: hasDeferredProperties, nodes: nodes };
    }
    exports.decorateNodes = decorateNodes;
    function decorate(actual, expected, instructions) {
        var nodes = [
            [Array.isArray(actual) ? tslib_1.__spread(actual) : [actual], Array.isArray(expected) ? tslib_1.__spread(expected) : [expected]]
        ];
        var wrappedNodeIds = [];
        var node = nodes.shift();
        while (node) {
            var _a = tslib_1.__read(node.map(function (nodes) {
                return nodes.filter(function (node) { return node != null && node !== true && node !== false; });
            }), 2), actualNodes = _a[0], expectedNodes = _a[1];
            var childNodes = [];
            var _loop_1 = function () {
                var _a;
                var actualNode = actualNodes.shift();
                var expectedNode = expectedNodes.shift();
                if (isWrappedNode(expectedNode)) {
                    if (wrappedNodeIds.indexOf(expectedNode.id) !== -1) {
                        throw new Error('Cannot use a wrapped test node more than once within an assertion template.');
                    }
                    var instruction = instructions.get(expectedNode.id);
                    if (instruction && isSameType(actualNode, expectedNode)) {
                        if (instruction.type === 'child') {
                            var expectedChild = expectedNode.children && expectedNode.children[0];
                            var actualChild = isNode(actualNode) && actualNode.children && actualNode.children[0];
                            if (typeof expectedChild === 'function' || typeof actualChild === 'function') {
                                if (typeof expectedChild === 'function') {
                                    var newExpectedChildren = expectedChild();
                                    expectedNode.children[0] = newExpectedChildren;
                                }
                                if (typeof actualChild === 'function') {
                                    var newActualChildren = actualChild.apply(void 0, tslib_1.__spread(instruction.params));
                                    actualNode.children[0] = newActualChildren;
                                }
                            }
                            else if (typeof expectedChild === 'object') {
                                var keys = Object.keys(expectedChild);
                                for (var i = 0; i < keys.length; i++) {
                                    var key = keys[i];
                                    if (typeof expectedChild[key] === 'function') {
                                        var newExpectedChildren = expectedChild[key]();
                                        expectedChild[key] = newExpectedChildren;
                                    }
                                    if (typeof actualChild === 'object' && typeof actualChild[key] === 'function') {
                                        var newActualChildren = actualChild[key].apply(actualChild, tslib_1.__spread((instruction.params[key] || [])));
                                        actualChild[key] = newActualChildren;
                                    }
                                }
                            }
                        }
                        else if (instruction.type === 'property' &&
                            isNode(actualNode) &&
                            typeof actualNode.properties[instruction.key] === 'function') {
                            (_a = actualNode.properties)[instruction.key].apply(_a, tslib_1.__spread(instruction.params));
                        }
                    }
                    wrappedNodeIds.push(expectedNode.id);
                }
                if (isIgnoredNode(expectedNode)) {
                    var index = array_1.findIndex(expectedNode.parent.children, function (child) { return child === expectedNode; });
                    if (index !== -1) {
                        if (isSameType(expectedNode, actualNode)) {
                            expectedNode.parent.children[index] = actualNode || expectedNode;
                        }
                    }
                }
                if (isNode(expectedNode) && isNode(actualNode)) {
                    var propertyKeys = Object.keys(expectedNode.properties);
                    for (var i = 0; i < propertyKeys.length; i++) {
                        var key = propertyKeys[i];
                        if (expectedNode.properties[key] != null && expectedNode.properties[key].type === 'compare') {
                            var result = expectedNode.properties[key](actualNode.properties[key]);
                            if (result) {
                                expectedNode.properties[key] = actualNode.properties[key];
                            }
                            else {
                                expectedNode.properties[key] = 'Compare FAILED';
                            }
                        }
                    }
                }
                if (isNode(expectedNode)) {
                    if (typeof expectedNode.properties === 'function') {
                        var actualProperties = isNode(actualNode) ? actualNode.properties : {};
                        expectedNode.properties = expectedNode.properties(actualProperties);
                    }
                }
                if (isNode(expectedNode)) {
                    var expectedChildren = expectedNode.children ? tslib_1.__spread(expectedNode.children) : [];
                    var actualChildren = isNode(actualNode) && actualNode.children ? tslib_1.__spread(actualNode.children) : [];
                    childNodes.push([actualChildren, expectedChildren]);
                }
                else if (expectedNode && typeof expectedNode === 'object') {
                    var expectedChildren = Object.keys(expectedNode).map(function (key) { return expectedNode[key]; });
                    var actualChildren = actualNode && typeof actualNode === 'object'
                        ? Object.keys(actualNode).map(function (key) { return actualNode[key]; })
                        : [];
                    childNodes.push([actualChildren, expectedChildren]);
                }
            };
            while (expectedNodes.length > 0) {
                _loop_1();
            }
            childNodes.reverse();
            nodes = tslib_1.__spread(childNodes, nodes);
            node = nodes.shift();
        }
    }
    exports.decorate = decorate;
    exports.default = decorate;
});
//# sourceMappingURL=decorate.js.map