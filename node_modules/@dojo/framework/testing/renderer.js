(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./assertRender", "../core/Registry", "../core/vdom", "../core/util", "./decorate", "../core/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var assertRender_1 = require("./assertRender");
    var Registry_1 = require("../core/Registry");
    var vdom_1 = require("../core/vdom");
    var util_1 = require("../core/util");
    var decorate_1 = require("./decorate");
    var util_2 = require("../core/util");
    function isWrappedNode(value) {
        return Boolean(value && value.id && (vdom_1.isWNode(value) || vdom_1.isVNode(value)));
    }
    function findNode(renderResult, wrapped) {
        renderResult = decorate_1.decorateNodes(renderResult).nodes;
        var nodes = Array.isArray(renderResult) ? tslib_1.__spread(renderResult) : [renderResult];
        var _loop_1 = function () {
            var node = nodes.pop();
            if (isWrappedNode(node)) {
                if (node.id === wrapped.id) {
                    return { value: node };
                }
            }
            if (vdom_1.isVNode(node) || vdom_1.isWNode(node)) {
                var children = node.children || [];
                for (var i = 0; i < children.length; i++) {
                    if (typeof children[i] === 'function') {
                        children[i] = children[i]();
                    }
                }
                nodes = tslib_1.__spread(children, nodes);
            }
            else if (node && typeof node === 'object') {
                nodes = tslib_1.__spread(Object.keys(node).reduce(function (newNodes, key) {
                    if (typeof node[key] === 'function') {
                        var result = node[key]();
                        node[key] = result;
                        return Array.isArray(result) ? tslib_1.__spread(result, newNodes) : tslib_1.__spread([result], newNodes);
                    }
                    else if (typeof node[key] === 'object') {
                        var result = node[key];
                        return Array.isArray(result) ? tslib_1.__spread(result, newNodes) : tslib_1.__spread([result], newNodes);
                    }
                    return newNodes;
                }, []), nodes);
            }
        };
        while (nodes.length) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        throw new Error('Unable to find node');
    }
    var replaceChildren = function (wrapped, render, modifyChildrenFn) {
        var node = findNode(render, wrapped);
        var parent = node.parent;
        var siblings = parent ? parent.children : Array.isArray(render) ? render : [render];
        var newChildren = modifyChildrenFn(siblings.indexOf(node), tslib_1.__spread(siblings));
        if (!parent) {
            return newChildren;
        }
        parent.children = newChildren;
        return render;
    };
    function assertion(renderFunc) {
        var assertionResult = function () {
            var render = renderFunc();
            util_2.decorate(render, function (node) {
                if (vdom_1.isWNode(node) || vdom_1.isVNode(node)) {
                    delete node.properties['~key'];
                    delete node.properties['assertion-key'];
                }
            });
            return render;
        };
        assertionResult.setProperty = function (wrapped, property, value) {
            return assertion(function () {
                var render = renderFunc();
                var node = findNode(render, wrapped);
                node.properties[property] = value;
                return render;
            });
        };
        assertionResult.setProperties = function (wrapped, value) {
            return assertion(function () {
                var render = renderFunc();
                var node = findNode(render, wrapped);
                node.properties = value;
                return render;
            });
        };
        assertionResult.append = function (wrapped, children) {
            return assertionResult.setChildren(wrapped, children, 'append');
        };
        assertionResult.prepend = function (wrapped, children) {
            return assertionResult.setChildren(wrapped, children, 'prepend');
        };
        assertionResult.replaceChildren = function (wrapped, children) {
            return assertionResult.setChildren(wrapped, children, 'replace');
        };
        assertionResult.setChildren = function (wrapped, children, type) {
            if (type === void 0) { type = 'replace'; }
            return assertion(function () {
                var render = renderFunc();
                var node = findNode(render, wrapped);
                node.children = node.children || [];
                var childrenResult = children();
                if (!Array.isArray(childrenResult)) {
                    childrenResult = [childrenResult];
                }
                switch (type) {
                    case 'prepend':
                        node.children = tslib_1.__spread(childrenResult, node.children);
                        break;
                    case 'append':
                        node.children = tslib_1.__spread(node.children, childrenResult);
                        break;
                    case 'replace':
                        node.children = tslib_1.__spread(childrenResult);
                        break;
                }
                return render;
            });
        };
        assertionResult.insertBefore = function (wrapped, children) {
            return assertionResult.insertSiblings(wrapped, children, 'before');
        };
        assertionResult.insertAfter = function (wrapped, children) {
            return assertionResult.insertSiblings(wrapped, children, 'after');
        };
        assertionResult.insertSiblings = function (wrapped, children, type) {
            if (type === void 0) { type = 'after'; }
            return assertion(function () {
                var render = renderFunc();
                var insertedChildren = typeof children === 'function' ? children() : children;
                return replaceChildren(wrapped, render, function (index, children) {
                    if (type === 'after') {
                        children.splice.apply(children, tslib_1.__spread([index + 1, 0], insertedChildren));
                    }
                    else {
                        children.splice.apply(children, tslib_1.__spread([index, 0], insertedChildren));
                    }
                    return children;
                });
            });
        };
        assertionResult.getProperty = function (wrapped, property) {
            var render = renderFunc();
            var node = findNode(render, wrapped);
            return node.properties[property];
        };
        assertionResult.getProperties = function (wrapped) {
            var render = renderFunc();
            var node = findNode(render, wrapped);
            return node.properties;
        };
        assertionResult.getChildren = function (wrapped) {
            var render = renderFunc();
            var node = findNode(render, wrapped);
            return node.children || [];
        };
        assertionResult.replace = function (wrapped, newNode) {
            return assertion(function () {
                var render = renderFunc();
                return replaceChildren(wrapped, render, function (index, children) {
                    children.splice(index, 1, newNode);
                    return children;
                });
            });
        };
        assertionResult.remove = function (wrapped) {
            return assertion(function () {
                var render = renderFunc();
                return replaceChildren(wrapped, render, function (index, children) {
                    children.splice(index, 1);
                    return children;
                });
            });
        };
        return assertionResult;
    }
    exports.assertion = assertion;
    function wrap(node) {
        var id = util_1.uuid();
        var nodeFactory = function (properties, children) {
            var dNode = typeof node === 'string' ? vdom_1.v(node, properties, children) : vdom_1.w(node, properties, children);
            dNode.id = id;
            return dNode;
        };
        nodeFactory.id = id;
        nodeFactory.isFactory = true;
        if (typeof node === 'string') {
            nodeFactory.tag = nodeFactory;
        }
        return nodeFactory;
    }
    exports.wrap = wrap;
    function ignore(node) {
        var nodeFactory = function (properties, children) {
            var dNode = typeof node === 'string' ? vdom_1.v(node, properties, children) : vdom_1.w(node, properties, children);
            dNode.isIgnore = true;
            return dNode;
        };
        nodeFactory.isFactory = true;
        if (typeof node === 'string') {
            nodeFactory.tag = nodeFactory;
        }
        return nodeFactory;
    }
    exports.ignore = ignore;
    function compare(compareFunc) {
        compareFunc.type = 'compare';
        return compareFunc;
    }
    exports.compare = compare;
    var factory = vdom_1.create();
    function renderer(renderFunc, options) {
        if (options === void 0) { options = {}; }
        var invalidated = true;
        var wNode = renderFunc();
        var expectedRenderResult;
        var renderResult;
        var widget;
        var middleware = {};
        var properties = {};
        var children = [];
        var customDiffs = [];
        var customDiffNames = [];
        var childInstructions = new Map();
        var propertyInstructions = [];
        var mockMiddleware = options.middleware || [];
        if (Registry_1.isWidgetFunction(wNode.widgetConstructor)) {
            widget = wNode.widgetConstructor;
            var resolveMiddleware_1 = function (middlewares, mocks) {
                var keys = Object.keys(middlewares);
                var results = {};
                var uniqueId = util_1.uuid();
                var mockMiddlewareMap = new Map(mocks);
                for (var i = 0; i < keys.length; i++) {
                    var isMock = false;
                    var middleware_1 = middlewares[keys[i]]();
                    if (mockMiddlewareMap.has(middlewares[keys[i]])) {
                        middleware_1 = mockMiddlewareMap.get(middlewares[keys[i]]);
                        isMock = true;
                    }
                    var payload = {
                        id: uniqueId,
                        properties: function () {
                            return tslib_1.__assign({}, properties);
                        },
                        children: function () {
                            return children;
                        }
                    };
                    if (middleware_1.middlewares) {
                        var resolvedMiddleware = resolveMiddleware_1(middleware_1.middlewares, mocks);
                        payload.middleware = resolvedMiddleware;
                        results[keys[i]] = middleware_1.callback(payload);
                    }
                    else {
                        if (isMock) {
                            var result = middleware_1();
                            var resolvedMiddleware = resolveMiddleware_1(result.middlewares, mocks);
                            payload.middleware = resolvedMiddleware;
                            results[keys[i]] = result.callback(payload);
                        }
                        else {
                            results[keys[i]] = middleware_1.callback(payload);
                        }
                    }
                }
                return results;
            };
            mockMiddleware.push([
                vdom_1.invalidator,
                factory(function () { return function () {
                    invalidated = true;
                }; })
            ]);
            mockMiddleware.push([vdom_1.destroy, factory(function () { return function () { }; })]);
            mockMiddleware.push([
                vdom_1.diffProperty,
                factory(function () { return function (propName, propertiesOrDiff, diff) {
                    var _a;
                    var diffFunction = diff || propertiesOrDiff;
                    if (customDiffNames.indexOf(propName) === -1) {
                        customDiffNames.push(propName);
                        customDiffs.push([propName, diffFunction]);
                        var result = diffFunction({}, properties);
                        if (result) {
                            properties = tslib_1.__assign({}, properties, (_a = {}, _a[propName] = result, _a));
                        }
                    }
                }; })
            ]);
            middleware = resolveMiddleware_1(wNode.widgetConstructor.middlewares, mockMiddleware);
        }
        else {
            var widgetConstructor = wNode.widgetConstructor;
            if (typeof widgetConstructor === 'function') {
                widget = new /** @class */ (function (_super) {
                    tslib_1.__extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    class_1.prototype.invalidate = function () {
                        invalidated = true;
                        _super.prototype.invalidate.call(this);
                    };
                    return class_1;
                }(widgetConstructor))();
                _tryRender();
            }
            else {
                throw new Error('Renderer does not support registry items');
            }
        }
        function _tryRender() {
            var _a;
            var render;
            var wNode = renderFunc();
            if (Registry_1.isWidgetFunction(widget)) {
                for (var i = 0; i < customDiffs.length; i++) {
                    var _b = tslib_1.__read(customDiffs[i], 2), name_1 = _b[0], diff = _b[1];
                    var result = diff(properties, wNode.properties);
                    if (result) {
                        wNode.properties = tslib_1.__assign({}, wNode.properties, (_a = {}, _a[name_1] = result, _a));
                    }
                }
                vdom_1.propertiesDiff(properties, wNode.properties, function () {
                    invalidated = true;
                }, tslib_1.__spread(customDiffNames));
                if (children.length || wNode.children.length) {
                    invalidated = true;
                }
                properties = tslib_1.__assign({}, wNode.properties);
                children = wNode.children;
                if (invalidated) {
                    render = widget({ id: 'test', middleware: middleware, properties: function () { return properties; }, children: function () { return children; } });
                }
            }
            else {
                widget.__setProperties__(wNode.properties);
                widget.__setChildren__(wNode.children);
                if (invalidated) {
                    render = widget.__render__();
                }
            }
            if (invalidated) {
                var _c = decorate_1.decorateNodes(render), hasDeferredProperties = _c.hasDeferredProperties, nodes = _c.nodes;
                if (hasDeferredProperties) {
                    nodes = decorate_1.decorateNodes(render).nodes;
                }
                renderResult = nodes;
                invalidated = false;
            }
        }
        function _expect(expectedRenderFunc) {
            if (expectedRenderResult && propertyInstructions.length > 0) {
                propertyInstructions.forEach(function (instruction) {
                    decorate_1.default(renderResult, expectedRenderResult, new Map([[instruction.id, instruction]]));
                });
                propertyInstructions = [];
            }
            _tryRender();
            expectedRenderResult = expectedRenderFunc();
            expectedRenderResult = decorate_1.decorateNodes(expectedRenderResult).nodes;
            decorate_1.default(renderResult, expectedRenderResult, childInstructions);
            assertRender_1.default(renderResult, expectedRenderResult);
        }
        return {
            child: function (wrapped, params) {
                childInstructions.set(wrapped.id, { wrapped: wrapped, params: params, type: 'child' });
                invalidated = true;
            },
            property: function (wrapped, key) {
                var params = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    params[_i - 2] = arguments[_i];
                }
                if (!expectedRenderResult) {
                    throw new Error('To use `.property` please perform an initial expect');
                }
                propertyInstructions.push({ id: wrapped.id, wrapped: wrapped, params: params, type: 'property', key: key });
            },
            expect: function (expectedRenderFunc) {
                return _expect(expectedRenderFunc);
            }
        };
    }
    exports.renderer = renderer;
    exports.default = renderer;
});
//# sourceMappingURL=renderer.js.map