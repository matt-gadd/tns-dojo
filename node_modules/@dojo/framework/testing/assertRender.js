(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "diff", "../shim/WeakMap", "../shim/Set", "../shim/Map", "../shim/array", "../core/vdom"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var diff = require("diff");
    var WeakMap_1 = require("../shim/WeakMap");
    var Set_1 = require("../shim/Set");
    var Map_1 = require("../shim/Map");
    var array_1 = require("../shim/array");
    var vdom_1 = require("../core/vdom");
    var LINE_BREAK = '\n';
    var TAB = '\t';
    var widgetClassCounter = 0;
    var widgetMap = new WeakMap_1.default();
    function getTabs(depth) {
        if (depth === void 0) { depth = 0; }
        return new Array(depth + 1).join(TAB);
    }
    function isNode(value) {
        return vdom_1.isWNode(value) || vdom_1.isVNode(value);
    }
    function getTagName(node) {
        if (vdom_1.isVNode(node)) {
            return node.tag;
        }
        var widgetConstructor = node.widgetConstructor;
        var name;
        if (typeof widgetConstructor === 'string' || typeof widgetConstructor === 'symbol') {
            name = widgetConstructor.toString();
        }
        else {
            name = widgetConstructor.name;
            if (!name) {
                var id = widgetMap.get(widgetConstructor);
                if (id === undefined) {
                    id = ++widgetClassCounter;
                    widgetMap.set(widgetConstructor, id);
                }
                name = "Widget-" + id;
            }
        }
        return name;
    }
    function formatObject(obj, depth, style) {
        if (depth === void 0) { depth = 0; }
        var objectKeys = Object.keys(obj).sort();
        if (!objectKeys) {
            return '';
        }
        var tabs = getTabs(depth + 1);
        var sep = style === 'prop' ? '=' : ': ';
        var opening = style === 'prop' ? '{' : '';
        var closing = style === 'prop' ? '}' : '';
        return objectKeys.reduce(function (props, propKey, index) {
            var prop = obj[propKey];
            propKey = style === 'object' ? "\"" + propKey + "\"" : propKey;
            if (index < objectKeys.length) {
                props = "" + props + LINE_BREAK + tabs;
            }
            props = "" + props + propKey + sep;
            switch (typeof prop) {
                case 'function':
                    props = "" + props + opening + "function" + closing;
                    break;
                case 'boolean':
                    props = "" + props + opening + prop + closing;
                    break;
                case 'object':
                    var isArrayLike = prop instanceof Set_1.default || prop instanceof Map_1.default || Array.isArray(prop);
                    if (isArrayLike) {
                        props = "" + props + opening + JSON.stringify(array_1.from(prop)) + closing;
                    }
                    else {
                        props = "" + props + opening + "{" + formatObject(prop, depth + 1, 'object') + LINE_BREAK + tabs + "}" + closing;
                    }
                    break;
                default:
                    props = "" + props + opening + JSON.stringify(prop) + closing;
                    break;
            }
            if (style === 'object' && index < objectKeys.length - 1) {
                props = props + ",";
            }
            return props;
        }, '');
    }
    function format(nodes, depth) {
        if (depth === void 0) { depth = 0; }
        nodes = Array.isArray(nodes) ? nodes : [nodes];
        var nodeString = nodes.reduce(function (str, node, index) {
            if (node == null || node === true || node === false) {
                return str;
            }
            if (index > 0) {
                str = str + "\n" + getTabs(depth);
            }
            if (typeof node === 'string') {
                return "" + str + node;
            }
            var tag = getTagName(node);
            str = str + "<" + tag;
            var propertyKeys = Object.keys(node.properties).sort();
            if (propertyKeys.length) {
                str = "" + str + formatObject(node.properties, depth, 'prop');
                str = "" + str + LINE_BREAK + getTabs(depth);
            }
            str = str + ">";
            if (node.children && node.children.length) {
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    if (!child) {
                        continue;
                    }
                    if (isNode(child) || typeof child === 'string') {
                        str = "" + str + LINE_BREAK + format(child, depth + 1);
                    }
                    else if (typeof child === 'function') {
                        str = "" + str + LINE_BREAK + getTabs(depth + 1) + "{";
                        str = "" + str + LINE_BREAK + getTabs(depth + 2) + "\"child function\"";
                        str = "" + str + LINE_BREAK + getTabs(depth + 1) + "}";
                    }
                    else if (typeof child === 'object') {
                        str = "" + str + LINE_BREAK + getTabs(depth + 1) + "{";
                        var childrenKeys = Object.keys(child);
                        for (var j = 0; j < childrenKeys.length; j++) {
                            str = "" + str + LINE_BREAK + getTabs(depth + 2) + childrenKeys[j] + ": (";
                            if (typeof child[childrenKeys[j]] !== 'function') {
                                str = "" + str + LINE_BREAK + format(child[childrenKeys[j]], depth + 3);
                            }
                            else {
                                str = "" + str + LINE_BREAK + getTabs(depth + 3) + "\"child function\"";
                            }
                            str = "" + str + LINE_BREAK + getTabs(depth + 2) + ")";
                            if (j < childrenKeys.length - 1) {
                                str = str + ",";
                            }
                        }
                        str = "" + str + LINE_BREAK + getTabs(depth + 1) + "}";
                    }
                }
            }
            if (tag) {
                str = "" + str + LINE_BREAK + getTabs(depth) + "</" + tag + ">";
            }
            return str;
        }, getTabs(depth));
        return nodeString;
    }
    function assertRender(actual, expected) {
        var parsedActual = format(actual);
        var parsedExpected = format(expected);
        var diffResult = diff.diffLines(parsedActual, parsedExpected);
        var diffFound = false;
        var parsedDiff = diffResult.reduce(function (result, part) {
            if (part.added) {
                diffFound = true;
                result = result + "(E)" + part.value.replace(/\n\t/g, '\n(E)\t');
            }
            else if (part.removed) {
                diffFound = true;
                result = result + "(A)" + part.value.replace(/\n\t/g, '\n(A)\t');
            }
            else {
                result = "" + result + part.value;
            }
            return result;
        }, '\n');
        if (diffFound) {
            throw new Error(parsedDiff);
        }
    }
    exports.assertRender = assertRender;
    exports.default = assertRender;
});
//# sourceMappingURL=assertRender.js.map