import assertRender from './assertRender';
import { isWidgetFunction } from '../core/Registry';
import { invalidator, diffProperty, destroy, create, propertiesDiff, w, v, isVNode, isWNode } from '../core/vdom';
import { uuid } from '../core/util';
import decorate, { decorateNodes } from './decorate';
import { decorate as coreDecorate } from '../core/util';
function isWrappedNode(value) {
    return Boolean(value && value.id && (isWNode(value) || isVNode(value)));
}
function findNode(renderResult, wrapped) {
    renderResult = decorateNodes(renderResult).nodes;
    let nodes = Array.isArray(renderResult) ? [...renderResult] : [renderResult];
    while (nodes.length) {
        let node = nodes.pop();
        if (isWrappedNode(node)) {
            if (node.id === wrapped.id) {
                return node;
            }
        }
        if (isVNode(node) || isWNode(node)) {
            const children = node.children || [];
            for (let i = 0; i < children.length; i++) {
                if (typeof children[i] === 'function') {
                    children[i] = children[i]();
                }
            }
            nodes = [...children, ...nodes];
        }
        else if (node && typeof node === 'object') {
            nodes = [
                ...Object.keys(node).reduce((newNodes, key) => {
                    if (typeof node[key] === 'function') {
                        const result = node[key]();
                        node[key] = result;
                        return Array.isArray(result) ? [...result, ...newNodes] : [result, ...newNodes];
                    }
                    else if (typeof node[key] === 'object') {
                        const result = node[key];
                        return Array.isArray(result) ? [...result, ...newNodes] : [result, ...newNodes];
                    }
                    return newNodes;
                }, []),
                ...nodes
            ];
        }
    }
    throw new Error('Unable to find node');
}
const replaceChildren = (wrapped, render, modifyChildrenFn) => {
    const node = findNode(render, wrapped);
    const parent = node.parent;
    const siblings = parent ? parent.children : Array.isArray(render) ? render : [render];
    const newChildren = modifyChildrenFn(siblings.indexOf(node), [...siblings]);
    if (!parent) {
        return newChildren;
    }
    parent.children = newChildren;
    return render;
};
export function assertion(renderFunc) {
    const assertionResult = () => {
        const render = renderFunc();
        coreDecorate(render, (node) => {
            if (isWNode(node) || isVNode(node)) {
                delete node.properties['~key'];
                delete node.properties['assertion-key'];
            }
        });
        return render;
    };
    assertionResult.setProperty = (wrapped, property, value) => {
        return assertion(() => {
            const render = renderFunc();
            const node = findNode(render, wrapped);
            node.properties[property] = value;
            return render;
        });
    };
    assertionResult.setProperties = (wrapped, value) => {
        return assertion(() => {
            const render = renderFunc();
            const node = findNode(render, wrapped);
            node.properties = value;
            return render;
        });
    };
    assertionResult.append = (wrapped, children) => {
        return assertionResult.setChildren(wrapped, children, 'append');
    };
    assertionResult.prepend = (wrapped, children) => {
        return assertionResult.setChildren(wrapped, children, 'prepend');
    };
    assertionResult.replaceChildren = (wrapped, children) => {
        return assertionResult.setChildren(wrapped, children, 'replace');
    };
    assertionResult.setChildren = (wrapped, children, type = 'replace') => {
        return assertion(() => {
            const render = renderFunc();
            const node = findNode(render, wrapped);
            node.children = node.children || [];
            let childrenResult = children();
            if (!Array.isArray(childrenResult)) {
                childrenResult = [childrenResult];
            }
            switch (type) {
                case 'prepend':
                    node.children = [...childrenResult, ...node.children];
                    break;
                case 'append':
                    node.children = [...node.children, ...childrenResult];
                    break;
                case 'replace':
                    node.children = [...childrenResult];
                    break;
            }
            return render;
        });
    };
    assertionResult.insertBefore = (wrapped, children) => {
        return assertionResult.insertSiblings(wrapped, children, 'before');
    };
    assertionResult.insertAfter = (wrapped, children) => {
        return assertionResult.insertSiblings(wrapped, children, 'after');
    };
    assertionResult.insertSiblings = (wrapped, children, type = 'after') => {
        return assertion(() => {
            const render = renderFunc();
            const insertedChildren = typeof children === 'function' ? children() : children;
            return replaceChildren(wrapped, render, (index, children) => {
                if (type === 'after') {
                    children.splice(index + 1, 0, ...insertedChildren);
                }
                else {
                    children.splice(index, 0, ...insertedChildren);
                }
                return children;
            });
        });
    };
    assertionResult.getProperty = (wrapped, property) => {
        const render = renderFunc();
        const node = findNode(render, wrapped);
        return node.properties[property];
    };
    assertionResult.getProperties = (wrapped) => {
        const render = renderFunc();
        const node = findNode(render, wrapped);
        return node.properties;
    };
    assertionResult.getChildren = (wrapped) => {
        const render = renderFunc();
        const node = findNode(render, wrapped);
        return node.children || [];
    };
    assertionResult.replace = (wrapped, newNode) => {
        return assertion(() => {
            const render = renderFunc();
            return replaceChildren(wrapped, render, (index, children) => {
                children.splice(index, 1, newNode);
                return children;
            });
        });
    };
    assertionResult.remove = (wrapped) => {
        return assertion(() => {
            const render = renderFunc();
            return replaceChildren(wrapped, render, (index, children) => {
                children.splice(index, 1);
                return children;
            });
        });
    };
    return assertionResult;
}
export function wrap(node) {
    const id = uuid();
    const nodeFactory = (properties, children) => {
        const dNode = typeof node === 'string' ? v(node, properties, children) : w(node, properties, children);
        dNode.id = id;
        return dNode;
    };
    nodeFactory.id = id;
    nodeFactory.isFactory = true;
    if (typeof node === 'string') {
        nodeFactory.tag = nodeFactory;
    }
    return nodeFactory;
}
export function ignore(node) {
    const nodeFactory = (properties, children) => {
        const dNode = typeof node === 'string' ? v(node, properties, children) : w(node, properties, children);
        dNode.isIgnore = true;
        return dNode;
    };
    nodeFactory.isFactory = true;
    if (typeof node === 'string') {
        nodeFactory.tag = nodeFactory;
    }
    return nodeFactory;
}
export function compare(compareFunc) {
    compareFunc.type = 'compare';
    return compareFunc;
}
const factory = create();
export function renderer(renderFunc, options = {}) {
    let invalidated = true;
    let wNode = renderFunc();
    let expectedRenderResult;
    let renderResult;
    let widget;
    let middleware = {};
    let properties = {};
    let children = [];
    let customDiffs = [];
    let customDiffNames = [];
    let childInstructions = new Map();
    let propertyInstructions = [];
    let mockMiddleware = options.middleware || [];
    if (isWidgetFunction(wNode.widgetConstructor)) {
        widget = wNode.widgetConstructor;
        const resolveMiddleware = (middlewares, mocks) => {
            const keys = Object.keys(middlewares);
            const results = {};
            const uniqueId = uuid();
            const mockMiddlewareMap = new Map(mocks);
            for (let i = 0; i < keys.length; i++) {
                let isMock = false;
                let middleware = middlewares[keys[i]]();
                if (mockMiddlewareMap.has(middlewares[keys[i]])) {
                    middleware = mockMiddlewareMap.get(middlewares[keys[i]]);
                    isMock = true;
                }
                const payload = {
                    id: uniqueId,
                    properties: () => {
                        return Object.assign({}, properties);
                    },
                    children: () => {
                        return children;
                    }
                };
                if (middleware.middlewares) {
                    const resolvedMiddleware = resolveMiddleware(middleware.middlewares, mocks);
                    payload.middleware = resolvedMiddleware;
                    results[keys[i]] = middleware.callback(payload);
                }
                else {
                    if (isMock) {
                        let result = middleware();
                        const resolvedMiddleware = resolveMiddleware(result.middlewares, mocks);
                        payload.middleware = resolvedMiddleware;
                        results[keys[i]] = result.callback(payload);
                    }
                    else {
                        results[keys[i]] = middleware.callback(payload);
                    }
                }
            }
            return results;
        };
        mockMiddleware.push([
            invalidator,
            factory(() => () => {
                invalidated = true;
            })
        ]);
        mockMiddleware.push([destroy, factory(() => () => { })]);
        mockMiddleware.push([
            diffProperty,
            factory(() => (propName, propertiesOrDiff, diff) => {
                const diffFunction = diff || propertiesOrDiff;
                if (customDiffNames.indexOf(propName) === -1) {
                    customDiffNames.push(propName);
                    customDiffs.push([propName, diffFunction]);
                    const result = diffFunction({}, properties);
                    if (result) {
                        properties = Object.assign({}, properties, { [propName]: result });
                    }
                }
            })
        ]);
        middleware = resolveMiddleware(wNode.widgetConstructor.middlewares, mockMiddleware);
    }
    else {
        const widgetConstructor = wNode.widgetConstructor;
        if (typeof widgetConstructor === 'function') {
            widget = new class extends widgetConstructor {
                invalidate() {
                    invalidated = true;
                    super.invalidate();
                }
            }();
            _tryRender();
        }
        else {
            throw new Error('Renderer does not support registry items');
        }
    }
    function _tryRender() {
        let render;
        const wNode = renderFunc();
        if (isWidgetFunction(widget)) {
            for (let i = 0; i < customDiffs.length; i++) {
                const [name, diff] = customDiffs[i];
                const result = diff(properties, wNode.properties);
                if (result) {
                    wNode.properties = Object.assign({}, wNode.properties, { [name]: result });
                }
            }
            propertiesDiff(properties, wNode.properties, () => {
                invalidated = true;
            }, [...customDiffNames]);
            if (children.length || wNode.children.length) {
                invalidated = true;
            }
            properties = Object.assign({}, wNode.properties);
            children = wNode.children;
            if (invalidated) {
                render = widget({ id: 'test', middleware, properties: () => properties, children: () => children });
            }
        }
        else {
            widget.__setProperties__(wNode.properties);
            widget.__setChildren__(wNode.children);
            if (invalidated) {
                render = widget.__render__();
            }
        }
        if (invalidated) {
            let { hasDeferredProperties, nodes } = decorateNodes(render);
            if (hasDeferredProperties) {
                nodes = decorateNodes(render).nodes;
            }
            renderResult = nodes;
            invalidated = false;
        }
    }
    function _expect(expectedRenderFunc) {
        if (expectedRenderResult && propertyInstructions.length > 0) {
            propertyInstructions.forEach((instruction) => {
                decorate(renderResult, expectedRenderResult, new Map([[instruction.id, instruction]]));
            });
            propertyInstructions = [];
        }
        _tryRender();
        expectedRenderResult = expectedRenderFunc();
        expectedRenderResult = decorateNodes(expectedRenderResult).nodes;
        decorate(renderResult, expectedRenderResult, childInstructions);
        assertRender(renderResult, expectedRenderResult);
    }
    return {
        child(wrapped, params) {
            childInstructions.set(wrapped.id, { wrapped, params, type: 'child' });
            invalidated = true;
        },
        property(wrapped, key, ...params) {
            if (!expectedRenderResult) {
                throw new Error('To use `.property` please perform an initial expect');
            }
            propertyInstructions.push({ id: wrapped.id, wrapped, params, type: 'property', key });
        },
        expect(expectedRenderFunc) {
            return _expect(expectedRenderFunc);
        }
    };
}
export default renderer;
//# sourceMappingURL=renderer.mjs.map