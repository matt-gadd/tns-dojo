import { WNode, DNode, Constructor, RenderResult, MiddlewareResultFactory, WNodeFactory, VNodeProperties, OptionalWNodeFactory, WidgetBaseInterface, DefaultChildrenWNodeFactory, DefaultMiddlewareResult } from '../core/interfaces';
import { WidgetBase } from '../core/WidgetBase';
import { Wrapped, WidgetFactory, CompareFunc, Comparable, NonComparable } from './interfaces';
export interface ChildInstruction {
    type: 'child';
    wrapped: Wrapped<any>;
    params: any;
}
export interface PropertyInstruction {
    type: 'property';
    id: string;
    key: string;
    wrapped: Wrapped<any>;
    params: any;
}
export declare type Instruction = ChildInstruction | PropertyInstruction;
export interface Child {
    <T extends WNodeFactory<{
        properties: any;
        children: any;
    }>>(wrapped: Wrapped<T>, params: T['children'] extends {
        [index: string]: any;
    } ? {
        [P in keyof T['children']]?: Parameters<T['children'][P]> extends never ? [] : Parameters<T['children'][P]>;
    } : T['children'] extends (...args: any[]) => RenderResult ? Parameters<T['children']> : never): void;
}
export declare type KnownKeys<T> = {
    [K in keyof T]: string extends K ? never : number extends K ? never : K;
} extends {
    [_ in keyof T]: infer U;
} ? U : never;
export declare type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends ((...args: any[]) => any | undefined) ? K : never;
}[keyof T];
export declare type RequiredVNodeProperties = Required<Pick<VNodeProperties, KnownKeys<VNodeProperties>>>;
export interface Property {
    <T extends WidgetBase<any>, K extends FunctionPropertyNames<Required<T['properties']>>>(wrapped: Wrapped<Constructor<T>>, key: K, ...params: Parameters<Exclude<T['properties'][K], CompareFunc<any>>>): void;
    <T extends OptionalWNodeFactory<{
        properties: Comparable<VNodeProperties>;
        children: any;
    }>, K extends FunctionPropertyNames<RequiredVNodeProperties>>(wrapped: Wrapped<T>, key: K, ...params: any[]): void;
    <T extends WidgetFactory, K extends FunctionPropertyNames<Required<T['properties']>>>(wrapped: Wrapped<T>, key: K, ...params: Parameters<Exclude<T['properties'][K], CompareFunc<any>>>): void;
}
interface RendererOptions {
    middleware?: [MiddlewareResultFactory<any, any, any, any>, () => DefaultMiddlewareResult][];
}
export declare type PropertiesComparatorFunction<T = any> = (actualProperties: T) => T;
export declare type TemplateChildren<T = DNode[]> = () => T;
export interface DecoratorResult<T> {
    hasDeferredProperties: boolean;
    nodes: T;
}
export interface AssertionResult {
    (): DNode | DNode[];
    append<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren<T['children']>): AssertionResult;
    append<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren<T['children']>): AssertionResult;
    prepend<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren<T['children']>): AssertionResult;
    prepend<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren<T['children']>): AssertionResult;
    replaceChildren<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren<T['children']>): AssertionResult;
    replaceChildren<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren<T['children']>): AssertionResult;
    insertBefore<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren): AssertionResult;
    insertBefore<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren): AssertionResult;
    insertAfter<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren): AssertionResult;
    insertAfter<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren): AssertionResult;
    insertSiblings<T extends WidgetBaseInterface>(target: T, children: TemplateChildren, type?: 'before' | 'after'): AssertionResult;
    setChildren<T extends WidgetFactory>(target: Wrapped<T>, children: TemplateChildren<T['children']>, type?: 'prepend' | 'replace' | 'append'): AssertionResult;
    setChildren<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, children: TemplateChildren<T['children']>, type?: 'prepend' | 'replace' | 'append'): AssertionResult;
    setProperty<T extends WidgetBaseInterface, K extends keyof T['properties']>(wrapped: Wrapped<Constructor<T>>, property: K, value: Exclude<T['properties'][K], CompareFunc<any>>): AssertionResult;
    setProperty<T extends WidgetFactory, K extends keyof T['properties']>(wrapped: Wrapped<T>, property: K, value: Exclude<T['properties'][K], CompareFunc<any>>): AssertionResult;
    setProperties<T extends WidgetBaseInterface>(wrapped: Wrapped<Constructor<T>>, value: NonComparable<T['properties']> | PropertiesComparatorFunction<NonComparable<T['properties']>>): AssertionResult;
    setProperties<T extends WidgetFactory>(wrapped: Wrapped<T>, value: NonComparable<T['properties']> | PropertiesComparatorFunction<NonComparable<T['properties']>>): AssertionResult;
    getChildren<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>): T['children'];
    getChildren<T extends WidgetFactory>(target: Wrapped<T>): T['children'];
    getProperty<T extends WidgetBaseInterface, K extends keyof T['properties']>(target: Wrapped<Constructor<T>>, property: K): Exclude<T['properties'][K], CompareFunc<any>>;
    getProperty<T extends WidgetFactory, K extends keyof T['properties']>(target: Wrapped<T>, property: K): Exclude<T['properties'][K], CompareFunc<any>>;
    getProperties<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>): NonComparable<T['properties']>;
    getProperties<T extends WidgetFactory>(target: Wrapped<T>): NonComparable<T['properties']>;
    replace<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>, node: DNode): AssertionResult;
    replace<T extends WidgetFactory>(target: Wrapped<T>, node: DNode): AssertionResult;
    remove<T extends WidgetBaseInterface>(target: Wrapped<Constructor<T>>): AssertionResult;
    remove<T extends WidgetFactory>(target: Wrapped<T>): AssertionResult;
}
export declare function assertion(renderFunc: () => DNode | DNode[]): AssertionResult;
export declare function wrap(node: string): Wrapped<OptionalWNodeFactory<{
    properties: Comparable<VNodeProperties>;
    children: DNode | (DNode | DNode[])[];
}>> & {
    tag: string;
};
export declare function wrap<T extends WidgetBaseInterface>(node: Constructor<T>): Wrapped<Constructor<WidgetBase<Comparable<T['properties']>>>>;
export declare function wrap<T extends OptionalWNodeFactory<any>>(node: T): Wrapped<OptionalWNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>>;
export declare function wrap<T extends DefaultChildrenWNodeFactory<any>>(node: T): Wrapped<DefaultChildrenWNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>>;
export declare function wrap<T extends WNodeFactory<any>>(node: T): Wrapped<WNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>>;
export declare function ignore(node: string): OptionalWNodeFactory<{
    properties: Comparable<VNodeProperties>;
    children: DNode | (DNode | DNode[])[];
}> & {
    tag: string;
};
export declare function ignore<T extends WidgetBaseInterface>(node: Constructor<T>): Constructor<WidgetBase<Comparable<T['properties']>>>;
export declare function ignore<T extends OptionalWNodeFactory<any>>(node: T): OptionalWNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>;
export declare function ignore<T extends DefaultChildrenWNodeFactory<any>>(node: T): DefaultChildrenWNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>;
export declare function ignore<T extends WNodeFactory<any>>(node: T): WNodeFactory<{
    properties: Comparable<T['properties']>;
    children: T['children'];
}>;
export declare function compare(compareFunc: (actual: unknown, expected: unknown) => boolean): CompareFunc<unknown>;
export interface Expect {
    (expectedRenderFunc: AssertionResult): void;
}
export interface RendererAPI {
    expect: Expect;
    child: Child;
    property: Property;
}
export declare function renderer(renderFunc: () => WNode, options?: RendererOptions): RendererAPI;
export default renderer;
