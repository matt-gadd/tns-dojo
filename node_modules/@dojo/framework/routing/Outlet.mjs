import { create, tsx, diffProperty, invalidator } from '../core/vdom';
import injector from '../core/middleware/injector';
import icache from '../core/middleware/icache';
const ROUTER_KEY = 'router';
const factory = create({ icache, injector, diffProperty, invalidator })
    .properties()
    .children();
export const Outlet = factory(function Outlet({ middleware: { icache, injector, diffProperty, invalidator }, properties, children }) {
    diffProperty('routerKey', (current, next) => {
        const { routerKey: currentRouterKey = ROUTER_KEY } = current;
        const { routerKey = ROUTER_KEY } = next;
        if (routerKey !== currentRouterKey) {
            const currentHandle = icache.get('handle');
            if (currentHandle) {
                currentHandle();
            }
            const handle = injector.subscribe(routerKey);
            if (handle) {
                icache.set('handle', () => handle);
            }
        }
        invalidator();
    });
    const { id, matcher, routerKey = ROUTER_KEY } = properties();
    const [outletChildren] = children();
    const currentHandle = icache.get('handle');
    if (!currentHandle) {
        const handle = injector.subscribe(routerKey);
        if (handle) {
            icache.set('handle', () => handle);
        }
    }
    const router = injector.get(routerKey);
    if (router) {
        const currentRouteContext = router.getMatchedRoute();
        const routeContextMap = router.getOutlet(id);
        if (routeContextMap && currentRouteContext) {
            if (typeof outletChildren === 'function') {
                return outletChildren(Object.assign({}, currentRouteContext, { router }));
            }
            let matches = Object.keys(outletChildren).reduce((matches, key) => {
                matches[key] = !!routeContextMap.get(key);
                return matches;
            }, {});
            if (matcher) {
                matches = matcher(matches, routeContextMap);
            }
            return (tsx("virtual", null, Object.keys(matches)
                .filter((key) => matches[key])
                .map((key) => {
                const renderer = outletChildren[key];
                if (typeof renderer === 'function') {
                    const context = routeContextMap.get(key) || currentRouteContext;
                    return renderer(Object.assign({}, context, { router }));
                }
                return renderer;
            })));
        }
    }
    return null;
});
export default Outlet;
//# sourceMappingURL=Outlet.mjs.map