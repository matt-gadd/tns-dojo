(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/global", "../core/Evented", "./history/HashHistory"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("../shim/global");
    var Evented_1 = require("../core/Evented");
    var HashHistory_1 = require("./history/HashHistory");
    var PARAM = '__PARAM__';
    var paramRegExp = new RegExp(/^{.+}$/);
    var ROUTE_SEGMENT_SCORE = 7;
    var DYNAMIC_SEGMENT_PENALTY = 2;
    function matchingParams(_a, _b) {
        var previousParams = _a.params;
        var params = _b.params;
        var matching = Object.keys(previousParams).every(function (key) { return previousParams[key] === params[key]; });
        if (!matching) {
            return false;
        }
        return Object.keys(params).every(function (key) { return previousParams[key] === params[key]; });
    }
    var Router = /** @class */ (function (_super) {
        tslib_1.__extends(Router, _super);
        function Router(config, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this._routes = [];
            _this._routeMap = Object.create(null);
            _this._matchedRoutes = Object.create(null);
            _this._matchedOutletMap = new Map();
            _this._currentParams = {};
            _this._currentQueryParams = {};
            /**
             * Called on change of the route by the the registered history manager. Matches the path against
             * the registered outlets.
             *
             * @param requestedPath The path of the requested route
             */
            _this._onChange = function (requestedPath) {
                requestedPath = _this._stripLeadingSlash(requestedPath);
                var previousMatchedRoutes = _this._matchedRoutes;
                _this._matchedRoutes = Object.create(null);
                _this._matchedOutletMap.clear();
                var _a = tslib_1.__read(requestedPath.split('?'), 2), path = _a[0], queryParamString = _a[1];
                _this._currentQueryParams = _this._getQueryParams(queryParamString);
                var segments = path.split('/');
                var routeConfigs = _this._routes.map(function (route) { return ({
                    route: route,
                    segments: tslib_1.__spread(segments),
                    parent: undefined,
                    params: {},
                    type: 'index'
                }); });
                var routeConfig;
                var matchedRoutes = [];
                var _loop_1 = function () {
                    var route = routeConfig.route, parent_1 = routeConfig.parent, segments_1 = routeConfig.segments, params = routeConfig.params;
                    var segmentIndex = 0;
                    var type = 'index';
                    var paramIndex = 0;
                    var routeMatch = true;
                    if (segments_1.length < route.segments.length) {
                        routeMatch = false;
                    }
                    else {
                        while (segments_1.length > 0) {
                            if (route.segments[segmentIndex] === undefined) {
                                type = 'partial';
                                break;
                            }
                            var segment = segments_1.shift();
                            if (route.segments[segmentIndex] === PARAM) {
                                params[route.params[paramIndex++]] = segment;
                                _this._currentParams = tslib_1.__assign({}, _this._currentParams, params);
                            }
                            else if (route.segments[segmentIndex] !== segment) {
                                routeMatch = false;
                                break;
                            }
                            segmentIndex++;
                        }
                    }
                    if (routeMatch) {
                        routeConfig.type = type;
                        matchedRoutes.push({ route: route, parent: parent_1, type: type, params: params, segments: [] });
                        if (segments_1.length) {
                            routeConfigs = tslib_1.__spread(routeConfigs, route.children.map(function (childRoute) { return ({
                                route: childRoute,
                                segments: tslib_1.__spread(segments_1),
                                parent: routeConfig,
                                type: type,
                                params: tslib_1.__assign({}, params)
                            }); }));
                        }
                    }
                };
                while ((routeConfig = routeConfigs.pop())) {
                    _loop_1();
                }
                var matchedRouteId = undefined;
                var matchedRoute = matchedRoutes.shift();
                while (matchedRoute && matchedRoutes.length) {
                    var currentMatch = matchedRoutes.shift();
                    if (currentMatch && currentMatch.route.score > matchedRoute.route.score) {
                        matchedRoute = currentMatch;
                    }
                }
                if (matchedRoute) {
                    if (matchedRoute.type === 'partial') {
                        matchedRoute.type = 'error';
                    }
                    matchedRouteId = matchedRoute.route.id;
                    var title = _this._options.setDocumentTitle
                        ? _this._options.setDocumentTitle({
                            id: matchedRouteId,
                            title: matchedRoute.route.title,
                            params: matchedRoute.params,
                            queryParams: _this._currentQueryParams
                        })
                        : matchedRoute.route.title;
                    if (title) {
                        global_1.default.document.title = title;
                    }
                    var _loop_2 = function () {
                        var type = matchedRoute.type, params = matchedRoute.params, route = matchedRoute.route;
                        var parent_2 = matchedRoute.parent;
                        var matchedRouteContext = {
                            id: route.id,
                            outlet: route.outlet,
                            queryParams: _this._currentQueryParams,
                            params: params,
                            type: type,
                            isError: function () { return type === 'error'; },
                            isExact: function () { return type === 'index'; }
                        };
                        var previousMatchedOutlet = previousMatchedRoutes[route.id];
                        var routeMap = _this._matchedOutletMap.get(route.outlet) || new Map();
                        routeMap.set(route.id, matchedRouteContext);
                        _this._matchedOutletMap.set(route.outlet, routeMap);
                        _this._matchedRoutes[route.id] = matchedRouteContext;
                        if (!previousMatchedOutlet || !matchingParams(previousMatchedOutlet, matchedRouteContext)) {
                            _this.emit({ type: 'route', route: matchedRouteContext, action: 'enter' });
                            _this.emit({ type: 'outlet', outlet: matchedRouteContext, action: 'enter' });
                        }
                        matchedRoute = parent_2;
                    };
                    while (matchedRoute) {
                        _loop_2();
                    }
                }
                else {
                    _this._matchedRoutes.errorRoute = {
                        id: 'errorRoute',
                        outlet: 'errorRoute',
                        queryParams: {},
                        params: {},
                        isError: function () { return true; },
                        isExact: function () { return false; },
                        type: 'error'
                    };
                }
                var previousMatchedOutletKeys = Object.keys(previousMatchedRoutes);
                for (var i = 0; i < previousMatchedOutletKeys.length; i++) {
                    var key = previousMatchedOutletKeys[i];
                    var matchedRoute_1 = _this._matchedRoutes[key];
                    if (!matchedRoute_1 || !matchingParams(previousMatchedRoutes[key], matchedRoute_1)) {
                        _this.emit({ type: 'route', route: previousMatchedRoutes[key], action: 'exit' });
                        _this.emit({ type: 'outlet', outlet: previousMatchedRoutes[key], action: 'exit' });
                    }
                }
                _this._currentMatchedRoute = matchedRouteId ? _this._matchedRoutes[matchedRouteId] : undefined;
                _this.emit({
                    type: 'nav',
                    outlet: matchedRouteId,
                    context: _this._currentMatchedRoute
                });
                if (_this._options.resetScroll) {
                    var _b = _this._options.window, window_1 = _b === void 0 ? global_1.default.window : _b;
                    try {
                        window_1.scroll(0, 0);
                    }
                    catch (e) {
                        // Catch errors if we're in an environment without window.scroll
                    }
                }
            };
            _this._options = options;
            _this._register(config);
            var autostart = options.autostart === undefined ? true : options.autostart;
            if (autostart) {
                _this.start();
            }
            return _this;
        }
        /**
         * Sets the path against the registered history manager
         *
         * @param path The path to set on the history manager
         */
        Router.prototype.setPath = function (path) {
            this._history.set(path);
        };
        Router.prototype.start = function () {
            var _a = this._options, _b = _a.HistoryManager, HistoryManager = _b === void 0 ? HashHistory_1.HashHistory : _b, base = _a.base, window = _a.window;
            this._history = new HistoryManager({ onChange: this._onChange, base: base, window: window });
            if (this._matchedRoutes.errorRoute && this._defaultRoute) {
                var path = this.link(this._defaultRoute);
                if (path) {
                    this.setPath(path);
                }
            }
        };
        /**
         * Generate a link for a given outlet identifier and optional params.
         *
         * @param outlet The outlet to generate a link for
         * @param params Optional Params for the generated link
         */
        Router.prototype.link = function (outlet, params) {
            if (params === void 0) { params = {}; }
            var route = this._routeMap[outlet];
            if (route === undefined) {
                return;
            }
            var linkPath = route.fullPath;
            if (route.fullQueryParams.length > 0) {
                var queryString = route.fullQueryParams.reduce(function (queryParamString, param, index) {
                    if (index > 0) {
                        return queryParamString + "&" + param + "={" + param + "}";
                    }
                    return "?" + param + "={" + param + "}";
                }, '');
                linkPath = "" + linkPath + queryString;
            }
            params = tslib_1.__assign({}, route.defaultParams, this._currentQueryParams, this._currentParams, params);
            if (Object.keys(params).length === 0 && route.fullParams.length > 0) {
                return undefined;
            }
            var fullParams = tslib_1.__spread(route.fullParams, route.fullQueryParams);
            for (var i = 0; i < fullParams.length; i++) {
                var param = fullParams[i];
                if (params[param]) {
                    linkPath = linkPath.replace("{" + param + "}", params[param]);
                }
                else {
                    return undefined;
                }
            }
            return this._history.prefix(linkPath);
        };
        /**
         * Returns the route context for the route identifier if one has been matched
         *
         * @param routeId The route identifer
         */
        Router.prototype.getRoute = function (routeId) {
            return this._matchedRoutes[routeId];
        };
        Router.prototype.getOutlet = function (outletId) {
            return this._matchedOutletMap.get(outletId);
        };
        Router.prototype.getMatchedRoute = function () {
            return this._currentMatchedRoute;
        };
        Object.defineProperty(Router.prototype, "currentParams", {
            /**
             * Returns all the params for the current matched outlets
             */
            get: function () {
                return this._currentParams;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Strips the leading slash on a path if one exists
         *
         * @param path The path to strip a leading slash
         */
        Router.prototype._stripLeadingSlash = function (path) {
            if (path[0] === '/') {
                return path.slice(1);
            }
            return path;
        };
        /**
         * Registers the routing configuration
         *
         * @param config The configuration
         * @param routes The routes
         * @param parentRoute The parent route
         */
        Router.prototype._register = function (config, routes, parentRoute) {
            routes = routes ? routes : this._routes;
            for (var i = 0; i < config.length; i++) {
                var _a = config[i], path = _a.path, outlet = _a.outlet, children = _a.children, _b = _a.defaultRoute, defaultRoute = _b === void 0 ? false : _b, _c = _a.defaultParams, defaultParams = _c === void 0 ? {} : _c, id = _a.id, title = _a.title;
                var _d = tslib_1.__read(path.split('?'), 2), parsedPath = _d[0], queryParamString = _d[1];
                var queryParams = [];
                parsedPath = this._stripLeadingSlash(parsedPath);
                var segments = parsedPath.split('/');
                var route = {
                    params: [],
                    id: id,
                    outlet: outlet,
                    title: title,
                    path: parsedPath,
                    segments: segments,
                    defaultParams: parentRoute ? tslib_1.__assign({}, parentRoute.defaultParams, defaultParams) : defaultParams,
                    children: [],
                    fullPath: parentRoute ? parentRoute.fullPath + "/" + parsedPath : parsedPath,
                    fullParams: [],
                    fullQueryParams: [],
                    score: parentRoute ? parentRoute.score : 0
                };
                if (defaultRoute) {
                    this._defaultRoute = id;
                }
                for (var i_1 = 0; i_1 < segments.length; i_1++) {
                    var segment = segments[i_1];
                    route.score += ROUTE_SEGMENT_SCORE;
                    if (paramRegExp.test(segment)) {
                        route.score -= DYNAMIC_SEGMENT_PENALTY;
                        route.params.push(segment.replace('{', '').replace('}', ''));
                        segments[i_1] = PARAM;
                    }
                }
                if (queryParamString) {
                    queryParams = queryParamString.split('&').map(function (queryParam) {
                        return queryParam.replace('{', '').replace('}', '');
                    });
                }
                route.fullQueryParams = parentRoute ? tslib_1.__spread(parentRoute.fullQueryParams, queryParams) : queryParams;
                route.fullParams = parentRoute ? tslib_1.__spread(parentRoute.fullParams, route.params) : route.params;
                if (children && children.length > 0) {
                    this._register(children, route.children, route);
                }
                this._routeMap[id] = route;
                routes.push(route);
            }
        };
        /**
         * Returns an object of query params
         *
         * @param queryParamString The string of query params, e.g `paramOne=one&paramTwo=two`
         */
        Router.prototype._getQueryParams = function (queryParamString) {
            var queryParams = {};
            if (queryParamString) {
                var queryParameters = queryParamString.split('&');
                for (var i = 0; i < queryParameters.length; i++) {
                    var _a = tslib_1.__read(queryParameters[i].split('='), 2), key = _a[0], value = _a[1];
                    queryParams[key] = value;
                }
            }
            return queryParams;
        };
        return Router;
    }(Evented_1.default));
    exports.Router = Router;
    exports.default = Router;
});
//# sourceMappingURL=Router.js.map