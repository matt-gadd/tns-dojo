import WeakMap from '../shim/WeakMap';
import Set from '../shim/Set';
import Map from '../shim/Map';
import { WNode, VNode, DNode, VNodeProperties, TransitionStrategy, DomVNode, LazyDefine, Constructor, RenderResult, WidgetBaseInterface, Callback, MiddlewareMap, WNodeFactory, OptionalWNodeFactory, UnionToIntersection, WidgetProperties, MiddlewareResultFactory, WidgetBaseTypes, RegistryLabel, DeferredVirtualProperties, DomOptions, DefaultChildrenWNodeFactory } from './interfaces';
import { Registry } from './Registry';
import RegistryHandler from './RegistryHandler';
import { NodeHandler } from './NodeHandler';
export declare namespace tsx.JSX {
    type Element = WNode;
    interface ElementAttributesProperty {
        __properties__: {};
    }
    interface IntrinsicElements {
        [key: string]: VNodeProperties;
    }
    interface ElementChildrenAttribute {
        __children__: {};
    }
}
export interface BaseNodeWrapper {
    id: string;
    owningId: string;
    node: WNode<any> | VNode;
    domNode?: Node;
    depth: number;
    order: number;
    requiresInsertBefore?: boolean;
    hasPreviousSiblings?: boolean;
    hasParentWNode?: boolean;
    namespace?: string;
    hasAnimations?: boolean;
    parentId: string;
    childDomWrapperId?: string;
}
export interface WNodeWrapper extends BaseNodeWrapper {
    node: WNode<any>;
    keys?: string[];
    instance?: any;
    mergeNodes?: Node[];
    nodeHandlerCalled?: boolean;
    registryItem?: Callback<any, any, any, RenderResult> | Constructor<any> | null;
    properties: any;
}
export interface WidgetMeta {
    widgetName: string;
    mountNode: HTMLElement;
    dirty: boolean;
    invalidator: () => void;
    middleware?: any;
    middlewareIds: string[];
    registryHandler?: RegistryHandler;
    registry: Registry;
    properties: any;
    originalProperties: any;
    children?: DNode[];
    rendering: boolean;
    nodeMap?: Map<string | number, HTMLElement>;
    destroyMap?: Map<string, () => void>;
    deferRefs: number;
    customDiffProperties?: Set<string>;
    customDiffMap?: Map<string, Map<string, (current: any, next: any) => any>>;
    propertiesCalled: boolean;
}
export interface WidgetData {
    onDetach: () => void;
    onAttach: () => void;
    dirty: boolean;
    nodeHandler: NodeHandler;
    invalidate?: Function;
    rendering: boolean;
    inputProperties: any;
    registry: RegistryHandler;
}
export interface VNodeWrapper extends BaseNodeWrapper {
    node: VNode | DomVNode;
    merged?: boolean;
    inserted?: boolean;
    deferredProperties?: VNodeProperties;
}
export declare type DNodeWrapper = VNodeWrapper | WNodeWrapper;
export interface MountOptions {
    sync: boolean;
    merge: boolean;
    transition?: TransitionStrategy;
    domNode: HTMLElement | null;
    registry: Registry;
	ownerDocument: any;
}
export interface Renderer {
    invalidate(): void;
    mount(mountOptions?: Partial<MountOptions>): void;
    unmount(): void;
}
export declare function setRendering(value: boolean): void;
export declare function incrementBlockCount(): void;
export declare function decrementBlockCount(): void;
export declare function isTextNode(item: any): item is Text;
export declare function isWNode<W extends WidgetBaseTypes = any>(child: any): child is WNode<W>;
export declare function isVNode(child: DNode): child is VNode;
export declare function isDomVNode(child: DNode): child is DomVNode;
export declare function isElementNode(value: any): value is Element;
/**
 * Wrapper function for calls to create a widget.
 */
export declare function w<W extends WidgetBaseTypes>(node: WNode<W>, properties: Partial<W['properties']>, children?: W['properties'] extends {
    __children__: any;
} ? W['properties']['__children__'] : W['children']): WNode<W>;
export declare function w<W extends WidgetBaseTypes>(widgetConstructor: Constructor<W> | RegistryLabel | LazyDefine<W>, properties: W['properties'], children?: W['children']): WNode<W>;
export declare function w<W extends WNodeFactory<any>>(widgetConstructor: W, properties: W['properties'], children: W['children'] extends any[] ? W['children'] : [W['children']]): WNode<W>;
export declare function w<W extends DefaultChildrenWNodeFactory<any>>(widgetConstructor: W, properties: W['properties'], children?: W['children']): WNode<W>;
export declare function w<W extends OptionalWNodeFactory<any>>(widgetConstructor: W, properties: W['properties'], children?: W['children'] extends any[] ? W['children'] : [W['children']]): WNode<W>;
/**
 * Wrapper function for calls to create VNodes.
 */
export declare function v(node: VNode, properties: VNodeProperties, children: undefined | DNode[]): VNode;
export declare function v(node: VNode, properties: VNodeProperties): VNode;
export declare function v(tag: string, children: undefined | DNode[]): VNode;
export declare function v<K extends keyof HTMLElementTagNameMap>(tag: K, properties: DeferredVirtualProperties | VNodeProperties<HTMLElementTagNameMap[K]>, children?: DNode[]): VNode;
export declare function v(tag: string, properties: DeferredVirtualProperties | VNodeProperties, children?: DNode[]): VNode;
export declare function v(tag: string): VNode;
/**
 * Create a VNode for an existing DOM Node.
 */
export declare function dom({ node, attrs, props, on, diffType, onAttach }: DomOptions, children?: DNode[]): DomVNode;
export declare const REGISTRY_ITEM = "__registry_item";
export declare class FromRegistry<P> {
    static type: string;
    __properties__: P;
    name: string | undefined;
}
export declare function fromRegistry<P>(tag: string): Constructor<FromRegistry<P>>;
export declare function tsx(tag: any, properties?: {}, ...children: any[]): DNode;
export declare function propertiesDiff(current: any, next: any, invalidator: () => void, ignoreProperties: string[]): void;
export declare function create<T extends MiddlewareMap, MiddlewareProps = ReturnType<T[keyof T]>['properties']>(middlewares?: T): {
    <ReturnValue>(callback: Callback<WidgetProperties & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>): ReturnValue extends RenderResult ? DefaultChildrenWNodeFactory<{
        properties: WidgetProperties & UnionToIntersection<MiddlewareProps>;
        children: DNode<any>[];
    }> : MiddlewareResultFactory<WidgetProperties & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>;
    children: <Children>() => {
        <ReturnValue>(callback: Callback<WidgetProperties & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>): ReturnValue extends RenderResult ? UnionToIntersection<Children> extends undefined ? OptionalWNodeFactory<{
            properties: WidgetProperties & UnionToIntersection<MiddlewareProps>;
            children: NonNullable<Children>;
        }> : WNodeFactory<{
            properties: WidgetProperties & UnionToIntersection<MiddlewareProps>;
            children: Children;
        }> : MiddlewareResultFactory<WidgetProperties & UnionToIntersection<MiddlewareProps>, NonNullable<Children>, T, ReturnValue>;
        properties: <Props>() => {
            <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>): ReturnValue extends RenderResult ? UnionToIntersection<Children> extends undefined ? OptionalWNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: NonNullable<Children>;
            }> : WNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: Children;
            }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>;
            key: (key: { [K in keyof Props]: Props[K] extends string | number ? K : never; }[keyof Props]) => <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>) => ReturnValue extends RenderResult ? UnionToIntersection<Children> extends undefined ? OptionalWNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: NonNullable<Children>;
            }> : WNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: Children;
            }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>;
        };
    };
    properties: <Props>() => {
        <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>): ReturnValue extends RenderResult ? DefaultChildrenWNodeFactory<{
            properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
            children: DNode<any>[];
        }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>;
        children: <Children>() => {
            <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>): ReturnValue extends RenderResult ? UnionToIntersection<Children> extends undefined ? OptionalWNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: NonNullable<Children>;
            }> : WNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: Children;
            }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>;
            key: (key: { [K in keyof Props]: Props[K] extends string | number ? K : never; }[keyof Props]) => <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>) => ReturnValue extends RenderResult ? UnionToIntersection<Children> extends undefined ? OptionalWNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: NonNullable<Children>;
            }> : WNodeFactory<{
                properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
                children: Children;
            }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, Children, T, ReturnValue>;
        };
        key: (key: { [K in keyof Props]: Props[K] extends string | number ? K : never; }[keyof Props]) => <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>) => ReturnValue extends RenderResult ? DefaultChildrenWNodeFactory<{
            properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
            children: DNode<any>[];
        }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, DNode<any>[], T, ReturnValue>;
    };
};
export declare const widgetInstanceMap: WeakMap<WidgetBaseInterface<WidgetProperties, DNode<any>>, WidgetData>;
export declare const invalidator: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, () => void>;
export declare const node: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, {
    get(key: string | number): HTMLElement | null;
}>;
export declare const diffProperty: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, {
    <T extends (...args: any) => any, K extends keyof ReturnType<T>>(property: K, properties: T, diff: (current: ReturnType<T>, next: ReturnType<T>) => void | ReturnType<T>[K]): void;
    (propertyName: string, diff: (current: any, next: any) => void): void;
}>;
export declare const destroy: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, (destroyFunction: () => void) => void>;
export declare const getRegistry: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, () => RegistryHandler | null>;
export declare const defer: MiddlewareResultFactory<WidgetProperties, DNode<any>[], MiddlewareMap<() => {
    api: {};
    properties: {};
}>, {
    pause(): void;
    resume(): void;
}>;
export declare function renderer(renderer: () => RenderResult): Renderer;
export default renderer;
