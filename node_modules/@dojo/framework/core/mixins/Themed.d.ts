import { Theme, Classes, ClassNames, Constructor, SupportedClassName, ThemeWithVariant, ThemeWithVariants } from './../interfaces';
import { Registry } from './../Registry';
import { WidgetBase } from './../WidgetBase';
import { ThemeInjector } from '../ThemeInjector';
export { Theme, Classes, ClassNames } from './../interfaces';
/**
 * Properties required for the Themed mixin
 */
export interface ThemedProperties<T = ClassNames> {
    /** Overriding custom theme for the widget */
    theme?: Theme | ThemeWithVariant;
    /** Map of widget keys and associated overriding classes */
    classes?: Classes;
    /** Extra classes to be applied to the widget */
    extraClasses?: {
        [P in keyof T]?: string;
    };
}
export declare const THEME_KEY = " _key";
export declare const INJECTED_THEME_KEY = "__theme_injector";
/**
 * Interface for the ThemedMixin
 */
export interface ThemedMixin<T = ClassNames> {
    theme(classes: SupportedClassName): SupportedClassName;
    theme(classes: SupportedClassName[]): SupportedClassName[];
    variant(): string | undefined;
    properties: ThemedProperties<T>;
}
/**
 * Decorator for base css classes
 */
export declare function theme(theme: {}): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;
/**
 * Convenience function that is given a theme and an optional registry, the theme
 * injector is defined against the registry, returning the theme.
 *
 * @param theme the theme to set
 * @param themeRegistry registry to define the theme injector against. Defaults
 * to the global registry
 *
 * @returns the theme injector used to set the theme
 */
export declare function registerThemeInjector(theme: Theme | ThemeWithVariants | ThemeWithVariant, themeRegistry: Registry): ThemeInjector;
/**
 * Function that returns a class decorated with with Themed functionality
 */
export declare function ThemedMixin<E, T extends Constructor<WidgetBase<ThemedProperties<E>>>>(Base: T): Constructor<ThemedMixin<E>> & T;
export default ThemedMixin;
