{"version":3,"file":"icache.mjs","sourceRoot":"","sources":["icache.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:interface-name */\nimport Map from '../../shim/Map';\nimport { create, invalidator, destroy } from '../vdom';\n\nconst factory = create({ invalidator, destroy });\n\ninterface CacheWrapper {\n\tstatus: 'pending' | 'resolved';\n\tvalue: any;\n}\n\nexport interface ICacheResult<S = void> {\n\tgetOrSet: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => Promise<T> : () => Promise<S[T]>,\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? undefined | T : undefined | S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => T : () => S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t};\n\tget<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T\n\t): void extends S ? T | undefined : S[T] | undefined;\n\tset: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? (value: T | undefined) => Promise<T> : (value: S[T] | undefined) => Promise<S[T]>,\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T | undefined : S[T] | undefined;\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? (value: T | undefined) => T : (value: S[T] | undefined) => S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t};\n\thas<T extends void extends S ? any : keyof S>(key: void extends S ? any : T): boolean;\n\tdelete<T extends void extends S ? any : keyof S>(key: void extends S ? any : T, invalidate?: boolean): void;\n\tclear(invalidate?: boolean): void;\n}\n\nconst icacheFactory = factory(\n\t({ middleware: { invalidator, destroy } }): ICacheResult<any> => {\n\t\tconst cacheMap = new Map<string, CacheWrapper>();\n\t\tdestroy(() => {\n\t\t\tcacheMap.clear();\n\t\t});\n\n\t\tconst api: any = {\n\t\t\tget: (key: any): any => {\n\t\t\t\tconst cachedValue = cacheMap.get(key);\n\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn cachedValue.value;\n\t\t\t}\n\t\t};\n\n\t\tapi.set = (key: any, value: any, invalidate: boolean = true): any => {\n\t\t\tconst current = api.get(key);\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tvalue = value(current);\n\t\t\t\tif (value && typeof value.then === 'function') {\n\t\t\t\t\tcacheMap.set(key, {\n\t\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\t\tvalue\n\t\t\t\t\t});\n\t\t\t\t\tvalue.then((result: any) => {\n\t\t\t\t\t\tconst cachedValue = cacheMap.get(key);\n\t\t\t\t\t\tif (cachedValue && cachedValue.value === value) {\n\t\t\t\t\t\t\tcacheMap.set(key, {\n\t\t\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tinvalidate && invalidator();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcacheMap.set(key, {\n\t\t\t\tstatus: 'resolved',\n\t\t\t\tvalue\n\t\t\t});\n\t\t\tinvalidate && invalidator();\n\t\t\treturn value;\n\t\t};\n\t\tapi.has = (key: any) => {\n\t\t\treturn cacheMap.has(key);\n\t\t};\n\t\tapi.delete = (key: any, invalidate: boolean = true) => {\n\t\t\tcacheMap.delete(key);\n\t\t\tinvalidate && invalidator();\n\t\t};\n\t\tapi.clear = (invalidate: boolean = true): void => {\n\t\t\tcacheMap.clear();\n\t\t\tinvalidate && invalidator();\n\t\t};\n\t\tapi.getOrSet = (key: any, value: any, invalidate: boolean = true): any | undefined => {\n\t\t\tlet cachedValue = cacheMap.get(key);\n\t\t\tif (!cachedValue) {\n\t\t\t\tapi.set(key, value, invalidate);\n\t\t\t}\n\t\t\tcachedValue = cacheMap.get(key);\n\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn cachedValue.value;\n\t\t};\n\t\treturn api;\n\t}\n);\n\nexport const createICacheMiddleware = <S = void>() => icacheFactory.withType<ICacheResult<S>>();\n\nexport const icache = createICacheMiddleware();\n\nexport default icache;\n"]}