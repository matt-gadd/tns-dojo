(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../../shim/Map", "../../shim/Set", "../vdom", "../../shim/Promise", "../diff"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Map_1 = require("../../shim/Map");
    var Set_1 = require("../../shim/Set");
    var vdom_1 = require("../vdom");
    var Promise_1 = require("../../shim/Promise");
    var diff_1 = require("../diff");
    function createResourceTemplate(template) {
        return template;
    }
    exports.createResourceTemplate = createResourceTemplate;
    function createResourceTemplateWithInit(template) {
        return template;
    }
    exports.createResourceTemplateWithInit = createResourceTemplateWithInit;
    function createMemoryResourceTemplate() {
        return tslib_1.__assign({}, exports.memoryTemplate);
    }
    exports.createMemoryResourceTemplate = createMemoryResourceTemplate;
    function defaultFilter(query, item, type) {
        if (type === void 0) { type = 'contains'; }
        var queryKeys = Object.keys(query);
        for (var i = 0; i < queryKeys.length; i++) {
            var queryKey = queryKeys[i];
            var value = query[queryKeys[i]];
            if (value) {
                var itemValue = item[queryKey];
                var result = true;
                if (typeof itemValue === 'string' && typeof value === 'string' && type !== 'exact') {
                    if (type === 'contains') {
                        result = item[queryKey].toLowerCase().indexOf(value.toLowerCase()) !== -1;
                    }
                    else {
                        result = item[queryKey].toLowerCase().indexOf(value.toLowerCase()) === 0;
                    }
                }
                else {
                    result = value === item[queryKey];
                }
                if (!result) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.defaultFilter = defaultFilter;
    function defaultFind(request, _a) {
        var put = _a.put, get = _a.get;
        var type = request.type, options = request.options;
        var query = options.query;
        var data = get({ query: query }).data;
        var found;
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            if (item && defaultFilter(request.query, item, type)) {
                if (!found || i >= request.start) {
                    found = {
                        item: item,
                        index: i
                    };
                    if (i >= request.start) {
                        break;
                    }
                }
            }
        }
        put(found, request);
    }
    exports.defaultFind = defaultFind;
    exports.memoryTemplate = Object.freeze({
        init: function (_a, _b) {
            var data = _a.data;
            var put = _b.put;
            put({ data: data, total: data.length }, { offset: 0, size: 30, query: {} });
        },
        read: function (request, _a) {
            var get = _a.get, put = _a.put;
            var data = get().data;
            var offset = request.offset, size = request.size;
            var filteredData = Object.keys(request.query).length
                ? data.filter(function (item) { return item && defaultFilter(request.query, item, 'contains'); })
                : data;
            put({ data: filteredData.slice(offset, offset + size), total: filteredData.length }, request);
        },
        find: function (request, _a) {
            var get = _a.get, put = _a.put;
            var type = request.type, options = request.options;
            var query = options.query;
            var data = get({ query: query }).data;
            if (!data.length) {
                data = get().data.filter(function (item) { return defaultFilter(query, item); });
            }
            var found;
            for (var i = 0; i < data.length; i++) {
                var item = data[i];
                if (item && defaultFilter(request.query, item, type)) {
                    if (!found || i >= request.start) {
                        found = {
                            item: item,
                            index: i
                        };
                        if (i >= request.start) {
                            break;
                        }
                    }
                }
            }
            put(found, request);
        }
    });
    function getMetaKey(_a) {
        var query = _a.query, size = _a.size;
        return "size-" + size + "-query-" + JSON.stringify(query);
    }
    function getFindKey(findOptions) {
        var _a = getFindOptions(findOptions), options = _a.options, find = tslib_1.__rest(_a, ["options"]);
        return "size-" + options.size + "-query-" + JSON.stringify(options.query) + "-find-" + JSON.stringify(find);
    }
    function getReadKey(_a) {
        var page = _a.page, size = _a.size, query = _a.query;
        return "page-" + JSON.stringify(page) + "-size-" + size + "-query-" + JSON.stringify(query);
    }
    function getDataKey(_a) {
        var _b = (_a === void 0 ? {} : _a).query, query = _b === void 0 ? {} : _b;
        return "" + JSON.stringify(query);
    }
    function getFindOptions(findOptions) {
        var _a = findOptions.type, type = _a === void 0 ? 'contains' : _a, start = findOptions.start, query = findOptions.query, options = findOptions.options;
        return { type: type, start: start, query: query, options: options };
    }
    function isFindOptions(options) {
        return Boolean(options && !!options.options);
    }
    function isFindRequest(options) {
        return isFindOptions(options);
    }
    function isFindResponse(options) {
        return Boolean(options && !!options.item);
    }
    function transformData(item, transformConfig) {
        var transformedItem = {};
        var sourceKeys = [];
        Object.keys(transformConfig).forEach(function (key) {
            var _a;
            var sourceKey = transformConfig[key];
            transformedItem = tslib_1.__assign({}, transformedItem, (_a = {}, _a[key] = item[sourceKey], _a));
            sourceKeys.push(sourceKey);
        });
        Object.keys(item)
            .filter(function (key) { return sourceKeys.indexOf(key) === -1; })
            .forEach(function (key) {
            var _a;
            transformedItem = tslib_1.__assign({}, transformedItem, (_a = {}, _a[key] = item[key], _a));
        });
        return transformedItem;
    }
    function transformQuery(query, transformConfig) {
        var queryKeys = Object.keys(query);
        var transformedQuery = {};
        for (var i = 0; i < queryKeys.length; i++) {
            var queryKey = queryKeys[i];
            transformedQuery[transformConfig[queryKey] || queryKey] = query[queryKey];
        }
        return transformedQuery;
    }
    function transformOptions(options, transformConfig) {
        if (transformConfig) {
            if (isFindOptions(options) && options.options.query) {
                var query = transformQuery(options.options.query, transformConfig);
                options.options = tslib_1.__assign({}, options.options, { query: query });
            }
            if (options.query && transformConfig) {
                var query = transformQuery(options.query, transformConfig);
                return tslib_1.__assign({}, options, { query: query });
            }
        }
        return tslib_1.__assign({}, options);
    }
    function isTemplateWithInit(value) {
        return Boolean(value && value.init);
    }
    function diffInitOptions(current, next) {
        var keys = new Set_1.default(tslib_1.__spread(Object.keys(current), Object.keys(next)));
        return tslib_1.__spread(keys).some(function (initKey) { return diff_1.auto(current[initKey], next[initKey], 1).changed; });
    }
    function createResource(template, initOptions) {
        var dataMap = new Map_1.default();
        var metaMap = new Map_1.default();
        var statusMap = new Map_1.default();
        var findMap = new Map_1.default();
        var requestPageMap = new Map_1.default();
        var invalidatorMaps = {
            read: new Map_1.default(),
            find: new Map_1.default(),
            meta: new Map_1.default(),
            failed: new Map_1.default(),
            loading: new Map_1.default()
        };
        var read = template.read, find = template.find;
        function get(request) {
            if (request === void 0) { request = {}; }
            var dataKey = getDataKey(request);
            var data = dataMap.get(dataKey) || [];
            return { data: data, total: data.length };
        }
        function put(response, request) {
            if (isFindRequest(request) && (isFindResponse(response) || !response)) {
                setFind(response, request);
            }
            else if (!isFindRequest(request) && !isFindResponse(response) && response) {
                setData(response, request);
            }
        }
        if (isTemplateWithInit(template)) {
            template.init(initOptions, { put: put, get: get });
        }
        function invalidate(type, key) {
            var keyedInvalidatorMap = invalidatorMaps[type];
            var invalidatorSet = keyedInvalidatorMap.get(key);
            if (invalidatorSet) {
                tslib_1.__spread(invalidatorSet).forEach(function (invalidator) {
                    invalidator();
                });
            }
        }
        function invalidateAll() {
            Object.keys(invalidatorMaps).forEach(function (key) {
                var map = invalidatorMaps[key];
                map.forEach(function (invalidatorSet) {
                    invalidatorSet.forEach(function (invalidator) {
                        invalidator();
                    });
                });
            });
        }
        function subscribe(type, invalidator, key) {
            var keyedInvalidatorMap = invalidatorMaps[type];
            var invalidatorSet = keyedInvalidatorMap.get(key) || new Set_1.default();
            invalidatorSet.add(invalidator);
            keyedInvalidatorMap.set(key, invalidatorSet);
        }
        function subscribeRead(invalidator, options) {
            subscribe('read', invalidator, getReadKey(options));
        }
        function subscribeMeta(invalidator, options) {
            subscribe('meta', invalidator, getReadKey(options));
        }
        function subscribeFind(invalidator, options) {
            subscribe('find', invalidator, getFindKey(options));
        }
        function subscribeLoading(invalidator, options) {
            if (isFindOptions(options)) {
                subscribe('loading', invalidator, getFindKey(options));
            }
            else {
                subscribe('loading', invalidator, getReadKey(options));
            }
        }
        function subscribeFailed(invalidator, options) {
            if (isFindOptions(options)) {
                subscribe('failed', invalidator, getFindKey(options));
            }
            else {
                subscribe('failed', invalidator, getReadKey(options));
            }
        }
        function unsubscribe(invalidator) {
            Object.keys(invalidatorMaps).forEach(function (type) {
                var keyedInvalidatorMap = invalidatorMaps[type];
                var keys = keyedInvalidatorMap.keys();
                tslib_1.__spread(keys).forEach(function (key) {
                    var invalidatorSet = keyedInvalidatorMap.get(key);
                    if (invalidatorSet && invalidatorSet.has(invalidator)) {
                        invalidatorSet.delete(invalidator);
                        if (invalidatorSet.size === 0) {
                            keyedInvalidatorMap.delete(key);
                        }
                        else {
                            keyedInvalidatorMap.set(key, invalidatorSet);
                        }
                    }
                });
            });
        }
        function releaseResource() {
            dataMap.clear();
            metaMap.clear();
            statusMap.clear();
            requestPageMap.clear();
        }
        function isStatus(statusType, key) {
            var status = statusMap.get(key);
            if (status) {
                return status === statusType;
            }
            return false;
        }
        function setStatus(status, key) {
            statusMap.set(key, status);
        }
        function clearStatus(key) {
            statusMap.delete(key);
        }
        function isLoading(options) {
            var key = isFindOptions(options) ? getFindKey(options) : getReadKey(options);
            return isStatus('LOADING', key);
        }
        function isFailed(options) {
            var key = isFindOptions(options) ? getFindKey(options) : getReadKey(options);
            return isStatus('FAILED', key);
        }
        function setMeta(options, total) {
            var metaKey = getMetaKey(options);
            var meta = metaMap.get(metaKey);
            if (!meta) {
                meta = tslib_1.__assign({}, options, { total: total });
            }
            else {
                if (!meta.total || total > meta.total) {
                    meta.total = total;
                }
            }
            invalidate('meta', getMetaKey(options));
            metaMap.set(metaKey, tslib_1.__assign({}, meta));
        }
        function setData(response, request) {
            var data = response.data, total = response.total;
            var size = request.size, offset = request.offset, query = request.query;
            var dataKey = getDataKey(request);
            var cachedData = dataMap.get(dataKey) || [];
            var maxItem = total ? total : offset + data.length;
            for (var i = offset; i < maxItem; i += 1) {
                if (data[i - offset] === undefined) {
                    break;
                }
                cachedData[i] = data[i - offset];
            }
            clearStatus(dataKey);
            dataMap.set(dataKey, cachedData);
            var page = Math.floor(offset / size) + 1;
            setMeta({ size: size, query: query, page: page }, total);
            invalidate('read', getReadKey({ size: size, query: query, page: page }));
            return cachedData.slice(offset, offset + size).filter(function () { return true; });
        }
        function setFind(response, request) {
            var options = request.options;
            var size = options.size;
            var key = getFindKey(request);
            if (!response) {
                findMap.set(key, response);
            }
            else {
                findMap.set(key, tslib_1.__assign({}, response, { page: Math.floor(response.index / size) + 1, pageIndex: response.index % size }));
            }
            clearStatus(key);
            invalidate('find', getFindKey(request));
        }
        function getCachedPageData(options) {
            var size = options.size, page = options.page;
            var metaKey = getMetaKey(options);
            var dataKey = getDataKey(options);
            var requestedPages = requestPageMap.get(metaKey) || [];
            var cachedData = dataMap.get(dataKey);
            if (cachedData) {
                var offset = (page - 1) * size;
                var requestedCachedData = cachedData.slice(offset, offset + size).filter(function () { return true; });
                setMeta(options, cachedData.length);
                if (requestedCachedData.length === size || requestedPages.indexOf(page) !== -1) {
                    return requestedCachedData;
                }
            }
        }
        function getOrRead(options) {
            var pages = Array.isArray(options.page) ? options.page : [options.page];
            var size = options.size, query = options.query;
            var getOrReadResponse = [];
            var requestKey = getReadKey(options);
            var promises = [];
            var _loop_1 = function (i) {
                var page = pages[i];
                var offset = (page - 1) * size;
                var statusKey = getReadKey({ page: page, size: size, query: query });
                var metaKey = getMetaKey({ size: size, query: query, page: page });
                var requestedPages = requestPageMap.get(metaKey) || [];
                if (isLoading({ page: page, size: size, query: query }) || isFailed({ page: page, size: size, query: query })) {
                    getOrReadResponse.push(undefined);
                    return "continue";
                }
                var cachedData = getCachedPageData({ size: size, query: query, page: page });
                if (cachedData) {
                    getOrReadResponse.push(cachedData);
                    return "continue";
                }
                requestedPages.push(page);
                requestPageMap.set(metaKey, requestedPages);
                var response = read({ offset: offset, size: size, query: query }, {
                    get: get,
                    put: put
                });
                if (Promise_1.isThenable(response)) {
                    promises.push(response);
                    getOrReadResponse.push(undefined);
                    setStatus('LOADING', statusKey);
                    invalidate('loading', getReadKey({ size: size, page: page, query: query }));
                    response
                        .then(function () {
                        clearStatus(statusKey);
                        invalidate('read', getReadKey({ size: size, page: page, query: query }));
                        invalidate('loading', getReadKey({ size: size, page: page, query: query }));
                    })
                        .catch(function () {
                        setStatus('FAILED', statusKey);
                        invalidate('loading', getReadKey({ size: size, page: page, query: query }));
                        invalidate('failed', getReadKey({ size: size, page: page, query: query }));
                    });
                }
                else {
                    getOrReadResponse.push(getCachedPageData({ size: size, query: query, page: page }));
                }
            };
            for (var i = 0; i < pages.length; i++) {
                _loop_1(i);
            }
            if (promises.length) {
                setStatus('LOADING', requestKey);
                Promise.all(promises)
                    .then(function () {
                    clearStatus(requestKey);
                    invalidate('read', getReadKey(options));
                    invalidate('loading', getReadKey(options));
                })
                    .catch(function () {
                    setStatus('FAILED', requestKey);
                    invalidate('loading', getReadKey(options));
                    invalidate('failed', getReadKey(options));
                });
            }
            return getOrReadResponse;
        }
        function resourceFind(options) {
            var key = getFindKey(getFindOptions(options));
            if (isStatus('LOADING', key) || isStatus('FAILED', key)) {
                return undefined;
            }
            if (findMap.has(key)) {
                return findMap.get(key);
            }
            var response = find(getFindOptions(options), { put: put, get: get });
            if (Promise_1.isThenable(response)) {
                setStatus('LOADING', key);
                invalidate('loading', getFindKey(options));
                response.then(function () {
                    clearStatus(key);
                    invalidate('find', getFindKey(options));
                    invalidate('loading', getFindKey(options));
                });
                return undefined;
            }
            else {
                return findMap.get(key);
            }
        }
        function resourceInit(options, requireDiff) {
            if (requireDiff === void 0) { requireDiff = false; }
            if (isTemplateWithInit(template)) {
                var reset = true;
                if (requireDiff) {
                    reset = diffInitOptions(initOptions, options);
                }
                if (reset) {
                    releaseResource();
                    template.init(options, { put: put, get: get });
                    invalidateAll();
                }
            }
            else {
                releaseResource();
            }
            initOptions = options;
        }
        function meta(options, request) {
            if (request === void 0) { request = false; }
            if (request) {
                getOrRead(options);
            }
            return metaMap.get(getMetaKey(options));
        }
        function destroy(id) {
            releaseResource();
            Object.keys(invalidatorMaps).forEach(function (key) {
                invalidatorMaps[key].clear();
            });
            if (initOptions) {
                var resourceMap = templateToResourceMap.get(template);
                if (resourceMap) {
                    resourceMap.delete(id + "/" + initOptions.id);
                }
            }
            templateToResourceMap.get(template);
        }
        return {
            find: resourceFind,
            getOrRead: getOrRead,
            init: resourceInit,
            meta: meta,
            subscribeMeta: subscribeMeta,
            subscribeRead: subscribeRead,
            subscribeFind: subscribeFind,
            subscribeFailed: subscribeFailed,
            subscribeLoading: subscribeLoading,
            unsubscribe: unsubscribe,
            isLoading: isLoading,
            isFailed: isFailed,
            destroy: destroy
        };
    }
    var optionInvalidatorMap = new Map_1.default();
    var templateToResourceMap = new Map_1.default();
    var idToResourceMap = new Map_1.default();
    function createOptionsWrapper() {
        var options = {
            page: 1,
            size: 30,
            query: {}
        };
        function invalidate() {
            var invalidatorSet = optionInvalidatorMap.get(setOptions) || [];
            tslib_1.__spread(invalidatorSet).forEach(function (invalidator) {
                invalidator();
            });
        }
        function setOptions(newOptions) {
            if (newOptions) {
                var calculatedOptions = tslib_1.__assign({}, options, newOptions);
                var changed = diff_1.auto(options, calculatedOptions, 2).changed;
                if (changed) {
                    options = calculatedOptions;
                    invalidate();
                }
            }
            return options;
        }
        setOptions.options = setOptions;
        return setOptions;
    }
    function isTemplate(value) {
        return Boolean(value && typeof value.read === 'function');
    }
    function isResource(value) {
        return Boolean(value && !!value.id);
    }
    function getResource(templateOrWrapper, id, init) {
        var templateId = (isResource(templateOrWrapper) ? templateOrWrapper.id : init && id + "/" + init.id) || 'global';
        var template = isResource(templateOrWrapper) ? templateOrWrapper.template : templateOrWrapper;
        var initOptions = isResource(templateOrWrapper) ? templateOrWrapper.initOptions : init;
        var resourceMap = templateToResourceMap.get(template) || new Map_1.default();
        var resource = resourceMap.get(templateId);
        var registeredResources = idToResourceMap.get(id) || new Set_1.default();
        if (!resource) {
            resource = createResource(template, initOptions);
            resourceMap.set(templateId, resource);
            templateToResourceMap.set(template, resourceMap);
            var ownerId = templateId.substring(0, templateId.indexOf('/'));
            var isOwner = ownerId === id;
            if (!isOwner) {
                var ownerResources = idToResourceMap.get(ownerId) || new Set_1.default();
                ownerResources.add({ resource: resource, type: 'owner' });
                idToResourceMap.set(ownerId, ownerResources);
            }
            registeredResources.add({ resource: resource, type: isOwner ? 'owner' : 'subscribed' });
        }
        else {
            if (init) {
                resource.init(init, true);
            }
            registeredResources.add({ resource: resource, type: 'subscribed' });
        }
        idToResourceMap.set(id, registeredResources);
        return resource;
    }
    var factory = vdom_1.create({ diffProperty: vdom_1.diffProperty, invalidator: vdom_1.invalidator, destroy: vdom_1.destroy });
    var resourceMiddlewareFactory = factory(function (_a) {
        var middlewareId = _a.id, _b = _a.middleware, diffProperty = _b.diffProperty, invalidator = _b.invalidator, destroy = _b.destroy;
        var optionsMap = new Map_1.default();
        destroy(function () {
            var resources = idToResourceMap.get(middlewareId);
            if (resources) {
                resources.forEach(function (resource) {
                    if (resource.type === 'subscribed') {
                        resource.resource.unsubscribe(invalidator);
                    }
                    else {
                        resource.resource.destroy(middlewareId);
                    }
                });
            }
            idToResourceMap.delete(middlewareId);
        });
        diffProperty('resource', function () {
            return {};
        }, function (_a, _b) {
            var current = _a.resource;
            var next = _b.resource;
            if (current && next) {
                var id = next.template.id || 'global';
                var currentInitOptions = current.template.initOptions;
                var nextInitOptions = next.template.initOptions;
                if (nextInitOptions) {
                    var changed = diffInitOptions(currentInitOptions || {}, nextInitOptions);
                    if (changed) {
                        var resourceMap = templateToResourceMap.get(next.template.template);
                        if (resourceMap) {
                            var resource = resourceMap.get(id);
                            if (resource) {
                                resource.init(nextInitOptions);
                                invalidator();
                            }
                        }
                    }
                }
                var nextOptions = next.options;
                var currOptions = current.options;
                if (currOptions && currOptions !== nextOptions) {
                    var invalidatorSet = optionInvalidatorMap.get(currOptions.options);
                    if (invalidatorSet) {
                        invalidatorSet.delete(invalidator);
                        invalidator();
                    }
                }
            }
            if (next) {
                var nextOptions_1 = next.options;
                var currOptions = current && current.options;
                if (nextOptions_1) {
                    var options = function (options) {
                        var invalidatorSet = optionInvalidatorMap.get(nextOptions_1.options) || new Set_1.default();
                        invalidatorSet.add(invalidator);
                        optionInvalidatorMap.set(nextOptions_1.options, invalidatorSet);
                        return nextOptions_1.options(options);
                    };
                    options.options = nextOptions_1.options;
                    if (!currOptions || currOptions.options !== nextOptions_1.options) {
                        invalidator();
                    }
                    return {
                        options: options,
                        template: next.template
                    };
                }
            }
        });
        var middleware = function (resource) {
            if (isTemplate(resource.template)) {
                var template = resource.template, transform = resource.transform, initOptions = resource.initOptions, rest = tslib_1.__rest(resource, ["template", "transform", "initOptions"]);
                return tslib_1.__assign({ template: {
                        template: template,
                        transform: transform,
                        id: initOptions ? middlewareId + "/" + initOptions.id : 'global',
                        initOptions: initOptions
                    } }, rest);
            }
            return resource;
        };
        middleware.createOptions = function (key) {
            var options = optionsMap.get(key);
            if (options) {
                return options;
            }
            var optionsWrapper = createOptionsWrapper();
            function setOptions(options) {
                var invalidatorSet = optionInvalidatorMap.get(optionsWrapper.options) || new Set_1.default();
                invalidatorSet.add(invalidator);
                optionInvalidatorMap.set(optionsWrapper.options, invalidatorSet);
                return optionsWrapper(options);
            }
            setOptions.options = optionsWrapper.options;
            optionsMap.set(key, setOptions);
            return setOptions;
        };
        middleware.getOrRead = function (template, options, init) {
            var resource = getResource(template, middlewareId, init);
            var transform = !isTemplate(template) && template.transform;
            var resourceOptions = transformOptions(options, transform);
            resource.subscribeRead(invalidator, options);
            var data = resource.getOrRead(resourceOptions);
            if (data && transform) {
                return data.map(function (items) {
                    if (items) {
                        return items.map(function (item) { return transformData(item, transform); });
                    }
                    return items;
                });
            }
            return data;
        };
        middleware.find = function (template, options, init) {
            var resource = getResource(template, middlewareId, init);
            var transform = !isTemplate(template) && template.transform;
            var findOptions = transformOptions(options, transform);
            resource.subscribeFind(invalidator, findOptions);
            var result = resource.find(findOptions);
            if (result && result.item && transform) {
                result.item = transformData(result.item, transform);
            }
            return result;
        };
        middleware.meta = function (template, options, request, init) {
            if (request === void 0) { request = false; }
            var resource = getResource(template, middlewareId, init);
            var transform = !isTemplate(template) && template.transform;
            var resourceOptions = transformOptions(options, transform);
            resource.subscribeMeta(invalidator, resourceOptions);
            if (request) {
                resource.subscribeRead(invalidator, resourceOptions);
            }
            return resource.meta(resourceOptions, request);
        };
        middleware.isLoading = function (template, options, init) {
            var resource = getResource(template, middlewareId, init);
            var transform = !isTemplate(template) && template.transform;
            var resourceOptions = transformOptions(options, transform);
            resource.subscribeLoading(invalidator, resourceOptions);
            return resource.isLoading(resourceOptions);
        };
        middleware.isFailed = function (template, options, init) {
            var resource = getResource(template, middlewareId, init);
            var transform = !isTemplate(template) && template.transform;
            var resourceOptions = transformOptions(options, transform);
            resource.subscribeFailed(invalidator, resourceOptions);
            return resource.isFailed(resourceOptions);
        };
        return middleware;
    });
    function createResourceMiddleware() {
        return resourceMiddlewareFactory.withType();
    }
    exports.createResourceMiddleware = createResourceMiddleware;
});
//# sourceMappingURL=resources.js.map