{"version":3,"file":"icache.js","sourceRoot":"","sources":["icache.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,mCAAmC;IACnC,sCAAiC;IACjC,gCAAuD;IAEvD,IAAM,OAAO,GAAG,aAAM,CAAC,EAAE,WAAW,oBAAA,EAAE,OAAO,gBAAA,EAAE,CAAC,CAAC;IAkDjD,IAAM,aAAa,GAAG,OAAO,CAC5B,UAAC,EAAwC;YAAtC,kBAAoC,EAAtB,4BAAW,EAAE,oBAAO;QACpC,IAAM,QAAQ,GAAG,IAAI,aAAG,EAAwB,CAAC;QACjD,OAAO,CAAC;YACP,QAAQ,CAAC,KAAK,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC;QAEH,IAAM,GAAG,GAAQ;YAChB,GAAG,EAAE,UAAC,GAAQ;gBACb,IAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACtC,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;oBACrD,OAAO,SAAS,CAAC;iBACjB;gBACD,OAAO,WAAW,CAAC,KAAK,CAAC;YAC1B,CAAC;SACD,CAAC;QAEF,GAAG,CAAC,GAAG,GAAG,UAAC,GAAQ,EAAE,KAAU,EAAE,UAA0B;YAA1B,2BAAA,EAAA,iBAA0B;YAC1D,IAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC7B,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;gBAChC,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;gBACvB,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;oBAC9C,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE;wBACjB,MAAM,EAAE,SAAS;wBACjB,KAAK,OAAA;qBACL,CAAC,CAAC;oBACH,KAAK,CAAC,IAAI,CAAC,UAAC,MAAW;wBACtB,IAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;wBACtC,IAAI,WAAW,IAAI,WAAW,CAAC,KAAK,KAAK,KAAK,EAAE;4BAC/C,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE;gCACjB,MAAM,EAAE,UAAU;gCAClB,KAAK,EAAE,MAAM;6BACb,CAAC,CAAC;4BACH,UAAU,IAAI,WAAW,EAAE,CAAC;yBAC5B;oBACF,CAAC,CAAC,CAAC;oBACH,OAAO,SAAS,CAAC;iBACjB;aACD;YACD,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE;gBACjB,MAAM,EAAE,UAAU;gBAClB,KAAK,OAAA;aACL,CAAC,CAAC;YACH,UAAU,IAAI,WAAW,EAAE,CAAC;YAC5B,OAAO,KAAK,CAAC;QACd,CAAC,CAAC;QACF,GAAG,CAAC,GAAG,GAAG,UAAC,GAAQ;YAClB,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC1B,CAAC,CAAC;QACF,GAAG,CAAC,MAAM,GAAG,UAAC,GAAQ,EAAE,UAA0B;YAA1B,2BAAA,EAAA,iBAA0B;YACjD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACrB,UAAU,IAAI,WAAW,EAAE,CAAC;QAC7B,CAAC,CAAC;QACF,GAAG,CAAC,KAAK,GAAG,UAAC,UAA0B;YAA1B,2BAAA,EAAA,iBAA0B;YACtC,QAAQ,CAAC,KAAK,EAAE,CAAC;YACjB,UAAU,IAAI,WAAW,EAAE,CAAC;QAC7B,CAAC,CAAC;QACF,GAAG,CAAC,QAAQ,GAAG,UAAC,GAAQ,EAAE,KAAU,EAAE,UAA0B;YAA1B,2BAAA,EAAA,iBAA0B;YAC/D,IAAI,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACpC,IAAI,CAAC,WAAW,EAAE;gBACjB,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;aAChC;YACD,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;gBACrD,OAAO,SAAS,CAAC;aACjB;YACD,OAAO,WAAW,CAAC,KAAK,CAAC;QAC1B,CAAC,CAAC;QACF,OAAO,GAAG,CAAC;IACZ,CAAC,CACD,CAAC;IAEW,QAAA,sBAAsB,GAAG,cAAgB,OAAA,aAAa,CAAC,QAAQ,EAAmB,EAAzC,CAAyC,CAAC;IAEnF,QAAA,MAAM,GAAG,8BAAsB,EAAE,CAAC;IAE/C,kBAAe,cAAM,CAAC","sourcesContent":["/* tslint:disable:interface-name */\nimport Map from '../../shim/Map';\nimport { create, invalidator, destroy } from '../vdom';\n\nconst factory = create({ invalidator, destroy });\n\ninterface CacheWrapper {\n\tstatus: 'pending' | 'resolved';\n\tvalue: any;\n}\n\nexport interface ICacheResult<S = void> {\n\tgetOrSet: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => Promise<T> : () => Promise<S[T]>,\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? undefined | T : undefined | S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => T : () => S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t};\n\tget<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T\n\t): void extends S ? T | undefined : S[T] | undefined;\n\tset: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? (value: T | undefined) => Promise<T> : (value: S[T] | undefined) => Promise<S[T]>,\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T | undefined : S[T] | undefined;\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? (value: T | undefined) => T : (value: S[T] | undefined) => S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T],\n\t\t\tinvalidate?: boolean\n\t\t): void extends S ? T : S[T];\n\t};\n\thas<T extends void extends S ? any : keyof S>(key: void extends S ? any : T): boolean;\n\tdelete<T extends void extends S ? any : keyof S>(key: void extends S ? any : T, invalidate?: boolean): void;\n\tclear(invalidate?: boolean): void;\n}\n\nconst icacheFactory = factory(\n\t({ middleware: { invalidator, destroy } }): ICacheResult<any> => {\n\t\tconst cacheMap = new Map<string, CacheWrapper>();\n\t\tdestroy(() => {\n\t\t\tcacheMap.clear();\n\t\t});\n\n\t\tconst api: any = {\n\t\t\tget: (key: any): any => {\n\t\t\t\tconst cachedValue = cacheMap.get(key);\n\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn cachedValue.value;\n\t\t\t}\n\t\t};\n\n\t\tapi.set = (key: any, value: any, invalidate: boolean = true): any => {\n\t\t\tconst current = api.get(key);\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tvalue = value(current);\n\t\t\t\tif (value && typeof value.then === 'function') {\n\t\t\t\t\tcacheMap.set(key, {\n\t\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\t\tvalue\n\t\t\t\t\t});\n\t\t\t\t\tvalue.then((result: any) => {\n\t\t\t\t\t\tconst cachedValue = cacheMap.get(key);\n\t\t\t\t\t\tif (cachedValue && cachedValue.value === value) {\n\t\t\t\t\t\t\tcacheMap.set(key, {\n\t\t\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tinvalidate && invalidator();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcacheMap.set(key, {\n\t\t\t\tstatus: 'resolved',\n\t\t\t\tvalue\n\t\t\t});\n\t\t\tinvalidate && invalidator();\n\t\t\treturn value;\n\t\t};\n\t\tapi.has = (key: any) => {\n\t\t\treturn cacheMap.has(key);\n\t\t};\n\t\tapi.delete = (key: any, invalidate: boolean = true) => {\n\t\t\tcacheMap.delete(key);\n\t\t\tinvalidate && invalidator();\n\t\t};\n\t\tapi.clear = (invalidate: boolean = true): void => {\n\t\t\tcacheMap.clear();\n\t\t\tinvalidate && invalidator();\n\t\t};\n\t\tapi.getOrSet = (key: any, value: any, invalidate: boolean = true): any | undefined => {\n\t\t\tlet cachedValue = cacheMap.get(key);\n\t\t\tif (!cachedValue) {\n\t\t\t\tapi.set(key, value, invalidate);\n\t\t\t}\n\t\t\tcachedValue = cacheMap.get(key);\n\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn cachedValue.value;\n\t\t};\n\t\treturn api;\n\t}\n);\n\nexport const createICacheMiddleware = <S = void>() => icacheFactory.withType<ICacheResult<S>>();\n\nexport const icache = createICacheMiddleware();\n\nexport default icache;\n"]}