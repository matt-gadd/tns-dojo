var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import Map from '../../shim/Map';
import Set from '../../shim/Set';
import { create, diffProperty, invalidator, destroy } from '../vdom';
import { isThenable } from '../../shim/Promise';
import { auto } from '../diff';
export function createResourceTemplate(template) {
    return template;
}
export function createResourceTemplateWithInit(template) {
    return template;
}
export function createMemoryResourceTemplate() {
    return Object.assign({}, memoryTemplate);
}
export function defaultFilter(query, item, type = 'contains') {
    const queryKeys = Object.keys(query);
    for (let i = 0; i < queryKeys.length; i++) {
        const queryKey = queryKeys[i];
        const value = query[queryKeys[i]];
        if (value) {
            const itemValue = item[queryKey];
            let result = true;
            if (typeof itemValue === 'string' && typeof value === 'string' && type !== 'exact') {
                if (type === 'contains') {
                    result = item[queryKey].toLowerCase().indexOf(value.toLowerCase()) !== -1;
                }
                else {
                    result = item[queryKey].toLowerCase().indexOf(value.toLowerCase()) === 0;
                }
            }
            else {
                result = value === item[queryKey];
            }
            if (!result) {
                return false;
            }
        }
    }
    return true;
}
export function defaultFind(request, { put, get }) {
    const { type, options } = request;
    const { query } = options;
    const { data } = get({ query });
    let found;
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        if (item && defaultFilter(request.query, item, type)) {
            if (!found || i >= request.start) {
                found = {
                    item,
                    index: i
                };
                if (i >= request.start) {
                    break;
                }
            }
        }
    }
    put(found, request);
}
export const memoryTemplate = Object.freeze({
    init: ({ data }, { put }) => {
        put({ data, total: data.length }, { offset: 0, size: 30, query: {} });
    },
    read: (request, { get, put }) => {
        const { data } = get();
        const { offset, size } = request;
        const filteredData = Object.keys(request.query).length
            ? data.filter((item) => item && defaultFilter(request.query, item, 'contains'))
            : data;
        put({ data: filteredData.slice(offset, offset + size), total: filteredData.length }, request);
    },
    find: (request, { get, put }) => {
        const { type, options } = request;
        const { query } = options;
        let { data } = get({ query });
        if (!data.length) {
            data = get().data.filter((item) => defaultFilter(query, item));
        }
        let found;
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            if (item && defaultFilter(request.query, item, type)) {
                if (!found || i >= request.start) {
                    found = {
                        item,
                        index: i
                    };
                    if (i >= request.start) {
                        break;
                    }
                }
            }
        }
        put(found, request);
    }
});
function getMetaKey({ query, size }) {
    return `size-${size}-query-${JSON.stringify(query)}`;
}
function getFindKey(findOptions) {
    const _a = getFindOptions(findOptions), { options } = _a, find = __rest(_a, ["options"]);
    return `size-${options.size}-query-${JSON.stringify(options.query)}-find-${JSON.stringify(find)}`;
}
function getReadKey({ page, size, query }) {
    return `page-${JSON.stringify(page)}-size-${size}-query-${JSON.stringify(query)}`;
}
function getDataKey({ query = {} } = {}) {
    return `${JSON.stringify(query)}`;
}
function getFindOptions(findOptions) {
    const { type = 'contains', start, query, options } = findOptions;
    return { type, start, query, options };
}
function isFindOptions(options) {
    return Boolean(options && !!options.options);
}
function isFindRequest(options) {
    return isFindOptions(options);
}
function isFindResponse(options) {
    return Boolean(options && !!options.item);
}
function transformData(item, transformConfig) {
    let transformedItem = {};
    let sourceKeys = [];
    Object.keys(transformConfig).forEach((key) => {
        const sourceKey = transformConfig[key];
        transformedItem = Object.assign({}, transformedItem, { [key]: item[sourceKey] });
        sourceKeys.push(sourceKey);
    });
    Object.keys(item)
        .filter((key) => sourceKeys.indexOf(key) === -1)
        .forEach((key) => {
        transformedItem = Object.assign({}, transformedItem, { [key]: item[key] });
    });
    return transformedItem;
}
function transformQuery(query, transformConfig) {
    const queryKeys = Object.keys(query);
    let transformedQuery = {};
    for (let i = 0; i < queryKeys.length; i++) {
        const queryKey = queryKeys[i];
        transformedQuery[transformConfig[queryKey] || queryKey] = query[queryKey];
    }
    return transformedQuery;
}
function transformOptions(options, transformConfig) {
    if (transformConfig) {
        if (isFindOptions(options) && options.options.query) {
            const query = transformQuery(options.options.query, transformConfig);
            options.options = Object.assign({}, options.options, { query });
        }
        if (options.query && transformConfig) {
            const query = transformQuery(options.query, transformConfig);
            return Object.assign({}, options, { query });
        }
    }
    return Object.assign({}, options);
}
function isTemplateWithInit(value) {
    return Boolean(value && value.init);
}
function diffInitOptions(current, next) {
    const keys = new Set([...Object.keys(current), ...Object.keys(next)]);
    return [...keys].some((initKey) => auto(current[initKey], next[initKey], 1).changed);
}
function createResource(template, initOptions) {
    const dataMap = new Map();
    const metaMap = new Map();
    const statusMap = new Map();
    const findMap = new Map();
    const requestPageMap = new Map();
    const invalidatorMaps = {
        read: new Map(),
        find: new Map(),
        meta: new Map(),
        failed: new Map(),
        loading: new Map()
    };
    const { read, find } = template;
    function get(request = {}) {
        const dataKey = getDataKey(request);
        const data = dataMap.get(dataKey) || [];
        return { data, total: data.length };
    }
    function put(response, request) {
        if (isFindRequest(request) && (isFindResponse(response) || !response)) {
            setFind(response, request);
        }
        else if (!isFindRequest(request) && !isFindResponse(response) && response) {
            setData(response, request);
        }
    }
    if (isTemplateWithInit(template)) {
        template.init(initOptions, { put, get });
    }
    function invalidate(type, key) {
        const keyedInvalidatorMap = invalidatorMaps[type];
        const invalidatorSet = keyedInvalidatorMap.get(key);
        if (invalidatorSet) {
            [...invalidatorSet].forEach((invalidator) => {
                invalidator();
            });
        }
    }
    function invalidateAll() {
        Object.keys(invalidatorMaps).forEach((key) => {
            const map = invalidatorMaps[key];
            map.forEach((invalidatorSet) => {
                invalidatorSet.forEach((invalidator) => {
                    invalidator();
                });
            });
        });
    }
    function subscribe(type, invalidator, key) {
        const keyedInvalidatorMap = invalidatorMaps[type];
        const invalidatorSet = keyedInvalidatorMap.get(key) || new Set();
        invalidatorSet.add(invalidator);
        keyedInvalidatorMap.set(key, invalidatorSet);
    }
    function subscribeRead(invalidator, options) {
        subscribe('read', invalidator, getReadKey(options));
    }
    function subscribeMeta(invalidator, options) {
        subscribe('meta', invalidator, getReadKey(options));
    }
    function subscribeFind(invalidator, options) {
        subscribe('find', invalidator, getFindKey(options));
    }
    function subscribeLoading(invalidator, options) {
        if (isFindOptions(options)) {
            subscribe('loading', invalidator, getFindKey(options));
        }
        else {
            subscribe('loading', invalidator, getReadKey(options));
        }
    }
    function subscribeFailed(invalidator, options) {
        if (isFindOptions(options)) {
            subscribe('failed', invalidator, getFindKey(options));
        }
        else {
            subscribe('failed', invalidator, getReadKey(options));
        }
    }
    function unsubscribe(invalidator) {
        Object.keys(invalidatorMaps).forEach((type) => {
            const keyedInvalidatorMap = invalidatorMaps[type];
            const keys = keyedInvalidatorMap.keys();
            [...keys].forEach((key) => {
                const invalidatorSet = keyedInvalidatorMap.get(key);
                if (invalidatorSet && invalidatorSet.has(invalidator)) {
                    invalidatorSet.delete(invalidator);
                    if (invalidatorSet.size === 0) {
                        keyedInvalidatorMap.delete(key);
                    }
                    else {
                        keyedInvalidatorMap.set(key, invalidatorSet);
                    }
                }
            });
        });
    }
    function releaseResource() {
        dataMap.clear();
        metaMap.clear();
        statusMap.clear();
        requestPageMap.clear();
    }
    function isStatus(statusType, key) {
        const status = statusMap.get(key);
        if (status) {
            return status === statusType;
        }
        return false;
    }
    function setStatus(status, key) {
        statusMap.set(key, status);
    }
    function clearStatus(key) {
        statusMap.delete(key);
    }
    function isLoading(options) {
        const key = isFindOptions(options) ? getFindKey(options) : getReadKey(options);
        return isStatus('LOADING', key);
    }
    function isFailed(options) {
        const key = isFindOptions(options) ? getFindKey(options) : getReadKey(options);
        return isStatus('FAILED', key);
    }
    function setMeta(options, total) {
        const metaKey = getMetaKey(options);
        let meta = metaMap.get(metaKey);
        if (!meta) {
            meta = Object.assign({}, options, { total });
        }
        else {
            if (!meta.total || total > meta.total) {
                meta.total = total;
            }
        }
        invalidate('meta', getMetaKey(options));
        metaMap.set(metaKey, Object.assign({}, meta));
    }
    function setData(response, request) {
        const { data, total } = response;
        const { size, offset, query } = request;
        const dataKey = getDataKey(request);
        const cachedData = dataMap.get(dataKey) || [];
        const maxItem = total ? total : offset + data.length;
        for (let i = offset; i < maxItem; i += 1) {
            if (data[i - offset] === undefined) {
                break;
            }
            cachedData[i] = data[i - offset];
        }
        clearStatus(dataKey);
        dataMap.set(dataKey, cachedData);
        const page = Math.floor(offset / size) + 1;
        setMeta({ size, query, page }, total);
        invalidate('read', getReadKey({ size, query, page }));
        return cachedData.slice(offset, offset + size).filter(() => true);
    }
    function setFind(response, request) {
        const { options } = request;
        const { size } = options;
        const key = getFindKey(request);
        if (!response) {
            findMap.set(key, response);
        }
        else {
            findMap.set(key, Object.assign({}, response, { page: Math.floor(response.index / size) + 1, pageIndex: response.index % size }));
        }
        clearStatus(key);
        invalidate('find', getFindKey(request));
    }
    function getCachedPageData(options) {
        const { size, page } = options;
        const metaKey = getMetaKey(options);
        const dataKey = getDataKey(options);
        const requestedPages = requestPageMap.get(metaKey) || [];
        const cachedData = dataMap.get(dataKey);
        if (cachedData) {
            const offset = (page - 1) * size;
            const requestedCachedData = cachedData.slice(offset, offset + size).filter(() => true);
            setMeta(options, cachedData.length);
            if (requestedCachedData.length === size || requestedPages.indexOf(page) !== -1) {
                return requestedCachedData;
            }
        }
    }
    function getOrRead(options) {
        const pages = Array.isArray(options.page) ? options.page : [options.page];
        const { size, query } = options;
        const getOrReadResponse = [];
        const requestKey = getReadKey(options);
        const promises = [];
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const offset = (page - 1) * size;
            const statusKey = getReadKey({ page, size, query });
            const metaKey = getMetaKey({ size, query, page });
            const requestedPages = requestPageMap.get(metaKey) || [];
            if (isLoading({ page, size, query }) || isFailed({ page, size, query })) {
                getOrReadResponse.push(undefined);
                continue;
            }
            const cachedData = getCachedPageData({ size, query, page });
            if (cachedData) {
                getOrReadResponse.push(cachedData);
                continue;
            }
            requestedPages.push(page);
            requestPageMap.set(metaKey, requestedPages);
            const response = read({ offset, size, query }, {
                get,
                put
            });
            if (isThenable(response)) {
                promises.push(response);
                getOrReadResponse.push(undefined);
                setStatus('LOADING', statusKey);
                invalidate('loading', getReadKey({ size, page, query }));
                response
                    .then(() => {
                    clearStatus(statusKey);
                    invalidate('read', getReadKey({ size, page, query }));
                    invalidate('loading', getReadKey({ size, page, query }));
                })
                    .catch(() => {
                    setStatus('FAILED', statusKey);
                    invalidate('loading', getReadKey({ size, page, query }));
                    invalidate('failed', getReadKey({ size, page, query }));
                });
            }
            else {
                getOrReadResponse.push(getCachedPageData({ size, query, page }));
            }
        }
        if (promises.length) {
            setStatus('LOADING', requestKey);
            Promise.all(promises)
                .then(() => {
                clearStatus(requestKey);
                invalidate('read', getReadKey(options));
                invalidate('loading', getReadKey(options));
            })
                .catch(() => {
                setStatus('FAILED', requestKey);
                invalidate('loading', getReadKey(options));
                invalidate('failed', getReadKey(options));
            });
        }
        return getOrReadResponse;
    }
    function resourceFind(options) {
        const key = getFindKey(getFindOptions(options));
        if (isStatus('LOADING', key) || isStatus('FAILED', key)) {
            return undefined;
        }
        if (findMap.has(key)) {
            return findMap.get(key);
        }
        const response = find(getFindOptions(options), { put, get });
        if (isThenable(response)) {
            setStatus('LOADING', key);
            invalidate('loading', getFindKey(options));
            response.then(() => {
                clearStatus(key);
                invalidate('find', getFindKey(options));
                invalidate('loading', getFindKey(options));
            });
            return undefined;
        }
        else {
            return findMap.get(key);
        }
    }
    function resourceInit(options, requireDiff = false) {
        if (isTemplateWithInit(template)) {
            let reset = true;
            if (requireDiff) {
                reset = diffInitOptions(initOptions, options);
            }
            if (reset) {
                releaseResource();
                template.init(options, { put, get });
                invalidateAll();
            }
        }
        else {
            releaseResource();
        }
        initOptions = options;
    }
    function meta(options, request = false) {
        if (request) {
            getOrRead(options);
        }
        return metaMap.get(getMetaKey(options));
    }
    function destroy(id) {
        releaseResource();
        Object.keys(invalidatorMaps).forEach((key) => {
            invalidatorMaps[key].clear();
        });
        if (initOptions) {
            const resourceMap = templateToResourceMap.get(template);
            if (resourceMap) {
                resourceMap.delete(`${id}/${initOptions.id}`);
            }
        }
        templateToResourceMap.get(template);
    }
    return {
        find: resourceFind,
        getOrRead,
        init: resourceInit,
        meta,
        subscribeMeta,
        subscribeRead,
        subscribeFind,
        subscribeFailed,
        subscribeLoading,
        unsubscribe,
        isLoading,
        isFailed,
        destroy
    };
}
const optionInvalidatorMap = new Map();
const templateToResourceMap = new Map();
const idToResourceMap = new Map();
function createOptionsWrapper() {
    let options = {
        page: 1,
        size: 30,
        query: {}
    };
    function invalidate() {
        const invalidatorSet = optionInvalidatorMap.get(setOptions) || [];
        [...invalidatorSet].forEach((invalidator) => {
            invalidator();
        });
    }
    function setOptions(newOptions) {
        if (newOptions) {
            const calculatedOptions = Object.assign({}, options, newOptions);
            const { changed } = auto(options, calculatedOptions, 2);
            if (changed) {
                options = calculatedOptions;
                invalidate();
            }
        }
        return options;
    }
    setOptions.options = setOptions;
    return setOptions;
}
function isTemplate(value) {
    return Boolean(value && typeof value.read === 'function');
}
function isResource(value) {
    return Boolean(value && !!value.id);
}
function getResource(templateOrWrapper, id, init) {
    const templateId = (isResource(templateOrWrapper) ? templateOrWrapper.id : init && `${id}/${init.id}`) || 'global';
    const template = isResource(templateOrWrapper) ? templateOrWrapper.template : templateOrWrapper;
    const initOptions = isResource(templateOrWrapper) ? templateOrWrapper.initOptions : init;
    const resourceMap = templateToResourceMap.get(template) || new Map();
    let resource = resourceMap.get(templateId);
    const registeredResources = idToResourceMap.get(id) || new Set();
    if (!resource) {
        resource = createResource(template, initOptions);
        resourceMap.set(templateId, resource);
        templateToResourceMap.set(template, resourceMap);
        const ownerId = templateId.substring(0, templateId.indexOf('/'));
        const isOwner = ownerId === id;
        if (!isOwner) {
            const ownerResources = idToResourceMap.get(ownerId) || new Set();
            ownerResources.add({ resource, type: 'owner' });
            idToResourceMap.set(ownerId, ownerResources);
        }
        registeredResources.add({ resource, type: isOwner ? 'owner' : 'subscribed' });
    }
    else {
        if (init) {
            resource.init(init, true);
        }
        registeredResources.add({ resource, type: 'subscribed' });
    }
    idToResourceMap.set(id, registeredResources);
    return resource;
}
const factory = create({ diffProperty, invalidator, destroy });
const resourceMiddlewareFactory = factory(({ id: middlewareId, middleware: { diffProperty, invalidator, destroy } }) => {
    const optionsMap = new Map();
    destroy(() => {
        const resources = idToResourceMap.get(middlewareId);
        if (resources) {
            resources.forEach((resource) => {
                if (resource.type === 'subscribed') {
                    resource.resource.unsubscribe(invalidator);
                }
                else {
                    resource.resource.destroy(middlewareId);
                }
            });
        }
        idToResourceMap.delete(middlewareId);
    });
    diffProperty('resource', () => {
        return {};
    }, ({ resource: current }, { resource: next }) => {
        if (current && next) {
            const id = next.template.id || 'global';
            const { template: { initOptions: currentInitOptions } } = current;
            const { template: { initOptions: nextInitOptions } } = next;
            if (nextInitOptions) {
                const changed = diffInitOptions(currentInitOptions || {}, nextInitOptions);
                if (changed) {
                    const resourceMap = templateToResourceMap.get(next.template.template);
                    if (resourceMap) {
                        const resource = resourceMap.get(id);
                        if (resource) {
                            resource.init(nextInitOptions);
                            invalidator();
                        }
                    }
                }
            }
            const nextOptions = next.options;
            const currOptions = current.options;
            if (currOptions && currOptions !== nextOptions) {
                const invalidatorSet = optionInvalidatorMap.get(currOptions.options);
                if (invalidatorSet) {
                    invalidatorSet.delete(invalidator);
                    invalidator();
                }
            }
        }
        if (next) {
            const nextOptions = next.options;
            const currOptions = current && current.options;
            if (nextOptions) {
                const options = (options) => {
                    const invalidatorSet = optionInvalidatorMap.get(nextOptions.options) || new Set();
                    invalidatorSet.add(invalidator);
                    optionInvalidatorMap.set(nextOptions.options, invalidatorSet);
                    return nextOptions.options(options);
                };
                options.options = nextOptions.options;
                if (!currOptions || currOptions.options !== nextOptions.options) {
                    invalidator();
                }
                return {
                    options,
                    template: next.template
                };
            }
        }
    });
    const middleware = function (resource) {
        if (isTemplate(resource.template)) {
            let { template, transform, initOptions } = resource, rest = __rest(resource, ["template", "transform", "initOptions"]);
            return Object.assign({ template: {
                    template,
                    transform,
                    id: initOptions ? `${middlewareId}/${initOptions.id}` : 'global',
                    initOptions
                } }, rest);
        }
        return resource;
    };
    middleware.createOptions = (key) => {
        const options = optionsMap.get(key);
        if (options) {
            return options;
        }
        const optionsWrapper = createOptionsWrapper();
        function setOptions(options) {
            const invalidatorSet = optionInvalidatorMap.get(optionsWrapper.options) || new Set();
            invalidatorSet.add(invalidator);
            optionInvalidatorMap.set(optionsWrapper.options, invalidatorSet);
            return optionsWrapper(options);
        }
        setOptions.options = optionsWrapper.options;
        optionsMap.set(key, setOptions);
        return setOptions;
    };
    middleware.getOrRead = (template, options, init) => {
        const resource = getResource(template, middlewareId, init);
        const transform = !isTemplate(template) && template.transform;
        const resourceOptions = transformOptions(options, transform);
        resource.subscribeRead(invalidator, options);
        const data = resource.getOrRead(resourceOptions);
        if (data && transform) {
            return data.map((items) => {
                if (items) {
                    return items.map((item) => transformData(item, transform));
                }
                return items;
            });
        }
        return data;
    };
    middleware.find = (template, options, init) => {
        const resource = getResource(template, middlewareId, init);
        const transform = !isTemplate(template) && template.transform;
        const findOptions = transformOptions(options, transform);
        resource.subscribeFind(invalidator, findOptions);
        const result = resource.find(findOptions);
        if (result && result.item && transform) {
            result.item = transformData(result.item, transform);
        }
        return result;
    };
    middleware.meta = (template, options, request = false, init) => {
        const resource = getResource(template, middlewareId, init);
        const transform = !isTemplate(template) && template.transform;
        const resourceOptions = transformOptions(options, transform);
        resource.subscribeMeta(invalidator, resourceOptions);
        if (request) {
            resource.subscribeRead(invalidator, resourceOptions);
        }
        return resource.meta(resourceOptions, request);
    };
    middleware.isLoading = (template, options, init) => {
        const resource = getResource(template, middlewareId, init);
        const transform = !isTemplate(template) && template.transform;
        const resourceOptions = transformOptions(options, transform);
        resource.subscribeLoading(invalidator, resourceOptions);
        return resource.isLoading(resourceOptions);
    };
    middleware.isFailed = (template, options, init) => {
        const resource = getResource(template, middlewareId, init);
        const transform = !isTemplate(template) && template.transform;
        const resourceOptions = transformOptions(options, transform);
        resource.subscribeFailed(invalidator, resourceOptions);
        return resource.isFailed(resourceOptions);
    };
    return middleware;
});
export function createResourceMiddleware() {
    return resourceMiddlewareFactory.withType();
}
//# sourceMappingURL=resources.mjs.map