var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import { create, invalidator, diffProperty, getRegistry } from '../vdom';
import icache from './icache';
import injector from './injector';
import Set from '../../shim/Set';
import { auto } from '../diff';
import { ThemeInjector, isThemeInjectorPayloadWithVariant, isThemeWithVariants, isThemeWithVariant } from '../ThemeInjector';
export const THEME_KEY = ' _key';
export const INJECTED_THEME_KEY = '__theme_injector';
function registerThemeInjector(theme, themeRegistry) {
    const themeInjector = new ThemeInjector(theme);
    themeRegistry.defineInjector(INJECTED_THEME_KEY, (invalidator) => {
        themeInjector.setInvalidator(invalidator);
        return () => themeInjector;
    });
    return themeInjector;
}
const factory = create({ invalidator, icache, diffProperty, injector, getRegistry }).properties();
export const theme = factory(({ middleware: { invalidator, icache, diffProperty, injector, getRegistry }, properties }) => {
    let themeKeys = new Set();
    diffProperty('theme', properties, (current, next) => {
        const { changed } = auto(current.theme, next.theme, 3);
        if (changed) {
            icache.clear();
            invalidator();
        }
    });
    diffProperty('classes', (current, next) => {
        let result = false;
        if ((current.classes && !next.classes) || (!current.classes && next.classes)) {
            result = true;
        }
        else if (current.classes && next.classes) {
            const keys = [...themeKeys.values()];
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                result = auto(current.classes[key], next.classes[key], 2).changed;
                if (result) {
                    break;
                }
            }
        }
        if (result) {
            icache.clear();
            invalidator();
        }
    });
    function getTheme() {
        const { theme } = properties();
        if (theme) {
            return theme;
        }
        const themeInjector = injector.get(INJECTED_THEME_KEY);
        if (themeInjector) {
            const themePayload = themeInjector.get();
            if (isThemeInjectorPayloadWithVariant(themePayload)) {
                return { theme: themePayload.theme, variant: themePayload.variant };
            }
            else if (themePayload) {
                return themePayload.theme;
            }
        }
    }
    const themeInjector = injector.get(INJECTED_THEME_KEY);
    if (!themeInjector) {
        const registry = getRegistry();
        if (registry) {
            registerThemeInjector(undefined, registry.base);
        }
    }
    injector.subscribe(INJECTED_THEME_KEY, () => {
        icache.clear();
        invalidator();
    });
    function set(theme, variant) {
        const currentTheme = injector.get(INJECTED_THEME_KEY);
        if (currentTheme) {
            if (isThemeWithVariants(theme)) {
                currentTheme.set(theme, variant);
            }
            else {
                currentTheme.set(theme);
            }
        }
    }
    return {
        classes(css) {
            const cachedTheme = icache.get(css);
            if (cachedTheme) {
                return cachedTheme;
            }
            const _a = THEME_KEY, key = css[_a], classes = __rest(css, [typeof _a === "symbol" ? _a : _a + ""]);
            themeKeys.add(key);
            let theme = classes;
            let { classes: currentClasses } = properties();
            let currentTheme = getTheme();
            if (currentTheme && isThemeWithVariant(currentTheme)) {
                currentTheme = isThemeWithVariants(currentTheme.theme)
                    ? currentTheme.theme.theme
                    : currentTheme.theme;
            }
            if (currentTheme && currentTheme[key]) {
                theme = Object.assign({}, theme, currentTheme[key]);
            }
            if (currentClasses && currentClasses[key]) {
                const classKeys = Object.keys(currentClasses[key]);
                for (let i = 0; i < classKeys.length; i++) {
                    const classKey = classKeys[i];
                    if (theme[classKey]) {
                        theme[classKey] = `${theme[classKey]} ${currentClasses[key][classKey].join(' ')}`;
                    }
                }
            }
            icache.set(css, theme, false);
            return theme;
        },
        variant() {
            const theme = getTheme();
            if (theme && isThemeWithVariant(theme)) {
                return theme.variant.value.root;
            }
        },
        set,
        get() {
            const currentTheme = injector.get(INJECTED_THEME_KEY);
            if (currentTheme) {
                return currentTheme.get();
            }
        }
    };
});
export default theme;
//# sourceMappingURL=theme.mjs.map