/* tslint:disable:interface-name */
import Map from '../../shim/Map';
import { create, invalidator, destroy } from '../vdom';
const factory = create({ invalidator, destroy });
const icacheFactory = factory(({ middleware: { invalidator, destroy } }) => {
    const cacheMap = new Map();
    destroy(() => {
        cacheMap.clear();
    });
    const api = {
        get: (key) => {
            const cachedValue = cacheMap.get(key);
            if (!cachedValue || cachedValue.status === 'pending') {
                return undefined;
            }
            return cachedValue.value;
        }
    };
    api.set = (key, value, invalidate = true) => {
        const current = api.get(key);
        if (typeof value === 'function') {
            value = value(current);
            if (value && typeof value.then === 'function') {
                cacheMap.set(key, {
                    status: 'pending',
                    value
                });
                value.then((result) => {
                    const cachedValue = cacheMap.get(key);
                    if (cachedValue && cachedValue.value === value) {
                        cacheMap.set(key, {
                            status: 'resolved',
                            value: result
                        });
                        invalidate && invalidator();
                    }
                });
                return undefined;
            }
        }
        cacheMap.set(key, {
            status: 'resolved',
            value
        });
        invalidate && invalidator();
        return value;
    };
    api.has = (key) => {
        return cacheMap.has(key);
    };
    api.delete = (key, invalidate = true) => {
        cacheMap.delete(key);
        invalidate && invalidator();
    };
    api.clear = (invalidate = true) => {
        cacheMap.clear();
        invalidate && invalidator();
    };
    api.getOrSet = (key, value, invalidate = true) => {
        let cachedValue = cacheMap.get(key);
        if (!cachedValue) {
            api.set(key, value, invalidate);
        }
        cachedValue = cacheMap.get(key);
        if (!cachedValue || cachedValue.status === 'pending') {
            return undefined;
        }
        return cachedValue.value;
    };
    return api;
});
export const createICacheMiddleware = () => icacheFactory.withType();
export const icache = createICacheMiddleware();
export default icache;
//# sourceMappingURL=icache.mjs.map