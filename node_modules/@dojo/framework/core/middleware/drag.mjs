import global from '../../shim/global';
import { assign } from '../../shim/object';
import { create, destroy, invalidator, node } from '../vdom';
import icache from './icache';
function getDelta(start, current) {
    return {
        x: current.client.x - start.client.x,
        y: current.client.y - start.client.y
    };
}
function createNodeData() {
    return {
        dragResults: Object.assign({}, emptyResults),
        last: createPositionMatrix(),
        start: createPositionMatrix()
    };
}
function createPosition() {
    return { x: 0, y: 0 };
}
function createPositionMatrix() {
    return {
        client: { x: 0, y: 0 },
        offset: { x: 0, y: 0 },
        page: { x: 0, y: 0 },
        screen: { x: 0, y: 0 }
    };
}
function getPositionMatrix(event) {
    return {
        client: {
            x: event.clientX,
            y: event.clientY
        },
        offset: {
            x: event.offsetX,
            y: event.offsetY
        },
        page: {
            x: event.pageX,
            y: event.pageY
        },
        screen: {
            x: event.screenX,
            y: event.screenY
        }
    };
}
function initNode(node) {
    node.style.touchAction = 'none';
    node.setAttribute('touch-action', 'none');
}
const emptyResults = Object.freeze({
    delta: Object.freeze(createPosition()),
    isDragging: false
});
const factory = create({ destroy, icache, invalidator, node });
export const drag = factory(({ middleware: { destroy, icache, invalidator, node } }) => {
    let nodeMap = new WeakMap();
    function getData(target) {
        const state = nodeMap.get(target);
        if (state) {
            return { state, target };
        }
    }
    function onDragStart(event) {
        const dragging = icache.get('dragging');
        if (!event.isPrimary && dragging) {
            const state = nodeMap.get(dragging);
            state.dragResults.isDragging = false;
            icache.set('dragging', undefined);
            return;
        }
        if (event.button !== 0) {
            return;
        }
        const data = getData(event.target);
        if (data) {
            const { state, target } = data;
            icache.set('dragging', target);
            state.last = state.start = getPositionMatrix(event);
            state.dragResults.delta = createPosition();
            state.dragResults.start = Object.assign({}, state.start);
            state.dragResults.isDragging = true;
            invalidator();
            event.preventDefault();
            event.stopPropagation();
        }
    }
    function onDrag(event) {
        const dragging = icache.get('dragging');
        if (!dragging) {
            return;
        }
        // state cannot be unset, using ! operator
        const state = nodeMap.get(dragging);
        state.last = getPositionMatrix(event);
        state.dragResults.delta = getDelta(state.start, state.last);
        invalidator();
        event.preventDefault();
        event.stopPropagation();
    }
    function onDragStop(event) {
        const dragging = icache.get('dragging');
        if (!dragging) {
            return;
        }
        // state cannot be unset, using ! operator
        const state = nodeMap.get(dragging);
        state.last = getPositionMatrix(event);
        state.dragResults.delta = getDelta(state.start, state.last);
        state.dragResults.isDragging = false;
        icache.set('dragging', undefined);
        event.preventDefault();
        event.stopPropagation();
    }
    const win = global;
    win.addEventListener('pointerdown', onDragStart);
    win.addEventListener('pointermove', onDrag, true);
    win.addEventListener('pointerup', onDragStop, true);
    destroy(() => {
        const win = global;
        win.removeEventListener('pointerdown', onDragStart);
        win.removeEventListener('pointermove', onDrag, true);
        win.removeEventListener('pointerup', onDragStop, true);
        nodeMap = new WeakMap();
    });
    return {
        get(key) {
            const domNode = node.get(key);
            if (!domNode) {
                return emptyResults;
            }
            if (!nodeMap.has(domNode)) {
                nodeMap.set(domNode, createNodeData());
                initNode(domNode);
                return emptyResults;
            }
            const state = nodeMap.get(domNode);
            const dragResults = assign({}, state.dragResults);
            state.start = state.last;
            state.dragResults.delta = createPosition();
            delete state.dragResults.start;
            return dragResults;
        }
    };
});
export default drag;
//# sourceMappingURL=drag.mjs.map