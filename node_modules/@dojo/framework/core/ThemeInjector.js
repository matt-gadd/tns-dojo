(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/global", "./Injector", "../shim/cssVariables", "../shim/Map", "./has"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("../shim/global");
    var Injector_1 = require("./Injector");
    var cssVariables_1 = require("../shim/cssVariables");
    var Map_1 = require("../shim/Map");
    var has_1 = require("./has");
    function isVariantModule(variant) {
        return typeof variant !== 'string';
    }
    exports.isVariantModule = isVariantModule;
    function isThemeWithVariant(theme) {
        return theme && theme.hasOwnProperty('variant');
    }
    exports.isThemeWithVariant = isThemeWithVariant;
    function isThemeWithVariants(theme) {
        return theme && theme.hasOwnProperty('variants');
    }
    exports.isThemeWithVariants = isThemeWithVariants;
    function isThemeInjectorPayloadWithVariant(theme) {
        return !!theme && theme.hasOwnProperty('variant');
    }
    exports.isThemeInjectorPayloadWithVariant = isThemeInjectorPayloadWithVariant;
    var processCssVariant = function (_) { };
    if (!has_1.default('dom-css-variables')) {
        var setUpCssVariantSupport = function () {
            var styleId = '__dojo_processed_styles';
            var processedCssMap = new Map_1.default();
            var variantStyleElement;
            function applyStyles(css) {
                var style = document.createElement('style');
                style.textContent = css;
                style.setAttribute('id', styleId);
                if (variantStyleElement && variantStyleElement.parentNode) {
                    variantStyleElement.parentNode.replaceChild(style, variantStyleElement);
                }
                else {
                    global_1.default.document.head.appendChild(style);
                }
                variantStyleElement = style;
            }
            return function processCssVariant(variantName) {
                var processedCss = processedCssMap.get(variantName);
                if (processedCss) {
                    applyStyles(processedCss);
                }
                else {
                    cssVariables_1.default({
                        exclude: "style[id=" + styleId + "]",
                        onSuccess: function (css) {
                            var temp = css;
                            var index = temp.indexOf(variantName);
                            var variantCss = '';
                            while (index !== -1) {
                                temp = temp.substring(index + variantName.length);
                                var match = temp.match(/\{([^}]+)\}/);
                                if (match) {
                                    if (variantCss) {
                                        variantCss = "" + variantCss.substring(0, variantCss.length - 1) + match[0].substring(1);
                                    }
                                    else {
                                        variantCss = match[0];
                                    }
                                }
                                index = temp.indexOf(variantName);
                            }
                            if (variantCss) {
                                css = ":root " + variantCss + css;
                            }
                            return css;
                        },
                        onComplete: function (css) {
                            processedCssMap.set(variantName, css);
                            applyStyles(css);
                        },
                        updateDOM: false,
                        silent: true
                    });
                }
            };
        };
        processCssVariant = setUpCssVariantSupport();
    }
    function createThemeInjectorPayload(theme, variant) {
        if (isThemeWithVariant(theme)) {
            if (typeof theme.variant === 'string') {
                return {
                    theme: theme.theme,
                    variant: { name: theme.variant, value: theme.theme.variants[theme.variant] }
                };
            }
            return { theme: theme.theme, variant: theme.variant };
        }
        else if (isThemeWithVariants(theme)) {
            variant = variant || 'default';
            if (isVariantModule(variant)) {
                if (!has_1.default('dom-css-variables')) {
                    processCssVariant(variant.value.root);
                }
                return { theme: theme, variant: variant };
            }
            if (!has_1.default('dom-css-variables')) {
                processCssVariant(theme.variants[variant].root);
            }
            return { theme: theme, variant: { name: variant, value: theme.variants[variant] } };
        }
        return { theme: theme };
    }
    var ThemeInjector = /** @class */ (function (_super) {
        tslib_1.__extends(ThemeInjector, _super);
        function ThemeInjector(theme) {
            return _super.call(this, theme ? createThemeInjectorPayload(theme) : theme) || this;
        }
        ThemeInjector.prototype.set = function (theme, variant) {
            _super.prototype.set.call(this, createThemeInjectorPayload(theme, variant));
        };
        ThemeInjector.prototype.get = function () {
            return _super.prototype.get.call(this);
        };
        return ThemeInjector;
    }(Injector_1.default));
    exports.ThemeInjector = ThemeInjector;
    exports.default = ThemeInjector;
});
//# sourceMappingURL=ThemeInjector.js.map