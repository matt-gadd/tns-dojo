let browserSpecificTransitionEndEventName = '';
let browserSpecificAnimationEndEventName = '';
function determineBrowserStyleNames(element) {
    if ('WebkitTransition' in element.style) {
        browserSpecificTransitionEndEventName = 'webkitTransitionEnd';
        browserSpecificAnimationEndEventName = 'webkitAnimationEnd';
    }
    else if ('transition' in element.style || 'MozTransition' in element.style) {
        browserSpecificTransitionEndEventName = 'transitionend';
        browserSpecificAnimationEndEventName = 'animationend';
    }
    else {
        throw new Error('Your browser is not supported');
    }
}
function initialize(element) {
    if (browserSpecificAnimationEndEventName === '') {
        determineBrowserStyleNames(element);
    }
}
function runAndCleanUp(element, startAnimation, finishAnimation) {
    initialize(element);
    let finished = false;
    let transitionEnd = function () {
        if (!finished) {
            finished = true;
            element.removeEventListener(browserSpecificTransitionEndEventName, transitionEnd);
            element.removeEventListener(browserSpecificAnimationEndEventName, transitionEnd);
            finishAnimation();
        }
    };
    startAnimation();
    element.addEventListener(browserSpecificAnimationEndEventName, transitionEnd);
    element.addEventListener(browserSpecificTransitionEndEventName, transitionEnd);
}
function exit(node, exitAnimation, active) {
    const exitAnimationClasses = exitAnimation.split(' ');
    const activeClasses = active && active !== true ? active.split(' ') : exitAnimationClasses.map((className) => `${className}-active`);
    runAndCleanUp(node, () => {
        exitAnimationClasses.forEach((className) => node.classList.add(className));
        requestAnimationFrame(function () {
            activeClasses.forEach((className) => node.classList.add(className));
        });
    }, () => {
        node && node.parentNode && node.parentNode.removeChild(node);
    });
}
function enter(node, enterAnimation, active) {
    const enterAnimationClasses = enterAnimation.split(' ');
    const activeClasses = active && active !== true ? active.split(' ') : enterAnimationClasses.map((className) => `${className}-active`);
    runAndCleanUp(node, () => {
        enterAnimationClasses.forEach((className) => node.classList.add(className));
        requestAnimationFrame(function () {
            activeClasses.forEach((className) => node.classList.add(className));
        });
    }, () => {
        enterAnimationClasses.forEach((className) => node.classList.remove(className));
        activeClasses.forEach((className) => node.classList.remove(className));
    });
}
export default {
    enter,
    exit
};
//# sourceMappingURL=cssTransitions.mjs.map